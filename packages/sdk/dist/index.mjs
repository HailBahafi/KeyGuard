var P={name:"ECDSA",namedCurve:"P-256"},E={name:"ECDSA",hash:{name:"SHA-256"}},p=class{constructor(){if(typeof globalThis.crypto<"u")this.crypto=globalThis.crypto;else if(typeof window<"u"&&window.crypto)this.crypto=window.crypto;else throw new Error("WebCrypto API is not available in this environment");if(!this.crypto.subtle)throw new Error("SubtleCrypto API is not available")}async generateKeyPair(){try{let e=await this.crypto.subtle.generateKey(P,!1,["sign","verify"]);if(!e.privateKey||!e.publicKey)throw new Error("Failed to generate key pair: missing keys");return e}catch(e){throw new Error(`Key generation failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async exportPublicKey(e){try{if(e.type!=="public")throw new Error("Provided key is not a public key");let r=await this.crypto.subtle.exportKey("spki",e);return d(r)}catch(r){throw new Error(`Public key export failed: ${r instanceof Error?r.message:"Unknown error"}`)}}async sign(e,r){try{if(e.type!=="private")throw new Error("Provided key is not a private key");let n=new TextEncoder().encode(r),o=await this.crypto.subtle.sign(E,e,n);return d(o)}catch(t){throw new Error(`Signing failed: ${t instanceof Error?t.message:"Unknown error"}`)}}createPayloadV1(e){let r=e.method.toUpperCase();return`kg-v1|${e.timestamp}|${r}|${e.pathAndQuery}|${e.bodySha256}|${e.nonce}|${e.apiKey}|${e.keyId}`}async hashSha256Base64(e){let r=typeof e=="string"?new TextEncoder().encode(e):e,t=await this.crypto.subtle.digest("SHA-256",r);return d(t)}generateNonce(e=16){let r=new Uint8Array(e);return this.crypto.getRandomValues(r),d(r)}};function d(i){let e=i instanceof ArrayBuffer?new Uint8Array(i):new Uint8Array(i.buffer,i.byteOffset,i.byteLength),r="";for(let t=0;t<e.length;t++)r+=String.fromCharCode(e[t]);if(typeof btoa<"u")return btoa(r);if(typeof Buffer<"u")return Buffer.from(e).toString("base64");throw new Error("No Base64 encoding method available")}function A(i){let e;if(typeof atob<"u")e=atob(i);else if(typeof Buffer<"u")e=Buffer.from(i,"base64").toString("binary");else throw new Error("No Base64 decoding method available");let r=new Uint8Array(e.length);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return r.buffer}import{get as u,set as h,del as w,createStore as k}from"idb-keyval";var c=k("keyguard-db","keyguard-store"),l={PUBLIC_KEY:"public-key",PRIVATE_KEY:"private-key"},g=class{async saveKeyPair(e,r){try{if(e.type!=="public")throw new Error("Invalid public key type");if(r.type!=="private")throw new Error("Invalid private key type");await h(l.PUBLIC_KEY,e,c),await h(l.PRIVATE_KEY,r,c)}catch(t){throw new Error(`Failed to save key pair: ${t instanceof Error?t.message:"Unknown error"}`)}}async getKeyPair(){try{let e=await u(l.PUBLIC_KEY,c),r=await u(l.PRIVATE_KEY,c);if(!e||!r)return null;if(e.type!=="public"||r.type!=="private")throw new Error("Retrieved keys have invalid types");return{publicKey:e,privateKey:r}}catch(e){throw new Error(`Failed to retrieve key pair: ${e instanceof Error?e.message:"Unknown error"}`)}}async clear(){try{await w(l.PUBLIC_KEY,c),await w(l.PRIVATE_KEY,c)}catch(e){throw new Error(`Failed to clear keys: ${e instanceof Error?e.message:"Unknown error"}`)}}};import S from"@fingerprintjs/fingerprintjs";async function m(){if(typeof process<"u"&&process.versions!=null&&process.versions.node!=null||typeof window>"u")return console.warn("\u26A0\uFE0F KeyGuard: Running in Node.js/Server environment - Using Mock Fingerprint"),{visitorId:"node-test-device-"+Date.now(),label:"Node.js Environment",metadata:{platform:"Node.js",userAgent:"Terminal",isServer:!0,timestamp:new Date().toISOString()}};try{let r=await(await S.load()).get(),t=r.components,n=C(t);return{visitorId:r.visitorId,label:n,metadata:r.components||{}}}catch(e){return console.warn("KeyGuard: FingerprintJS failed, falling back.",e),{visitorId:"fallback-"+Date.now(),label:"Unknown Device",metadata:{error:String(e)}}}}function C(i){let e=(a,y="")=>a&&typeof a=="object"&&"value"in a?a.value??y:y,r="Unknown Browser",t=String(e(i.vendor,"")),n=e(i.vendorFlavors,[]);t.includes("Google")||Array.isArray(n)&&n.includes("chrome")?r="Chrome":t.includes("Apple")||Array.isArray(n)&&n.includes("safari")?r="Safari":Array.isArray(n)&&n.includes("firefox")&&(r="Firefox");let o="Unknown OS",s=String(e(i.platform,""));return s.includes("Win")?o="Windows":s.includes("Mac")?o="macOS":s.includes("Linux")&&(o="Linux"),`${r} on ${o}`}var x={apiBaseUrl:"https://api.keyguard.dev"},v=class{constructor(e){if(!e.apiKey)throw new Error("KeyGuard SDK requires an apiKey");if(this.config={...x,...e},this.crypto=new p,this.config.storage)if(typeof this.config.storage=="string")if(this.config.storage==="browser")this.storage=new g;else throw this.config.storage==="memory"?new Error("Memory storage string shortcut not fully implemented. Pass instance of MemoryStorageAdapter instead."):new Error(`Unsupported storage type: ${this.config.storage}`);else this.storage=this.config.storage;else if(typeof window<"u"&&typeof indexedDB<"u")this.storage=new g;else throw new Error("No storage adapter provided and browser environment not detected. Please provide a custom storage adapter for Node.js environments.");this.config.fingerprintProvider&&(this.fingerprintProvider=this.config.fingerprintProvider)}async enroll(e){try{let r;if(this.fingerprintProvider?r=await this.fingerprintProvider.getFingerprint():r=await m(),await this.storage.getKeyPair())throw new Error("Device already enrolled. Call unenroll() first to re-enroll this device.");let n=await this.crypto.generateKeyPair();await this.storage.saveKeyPair(n.publicKey,n.privateKey);let o=await this.crypto.exportPublicKey(n.publicKey),s=await this.generateKeyId(n.publicKey),a=e||r.label;return{publicKey:o,keyId:s,deviceFingerprint:r.visitorId,label:a,userAgent:this.getUserAgent(),metadata:r.metadata}}catch(r){throw new Error(`Enrollment failed: ${r instanceof Error?r.message:"Unknown error"}`)}}async signRequest(e){try{let r=await this.storage.getKeyPair();if(!r)throw new Error("Device not enrolled. Call enroll() first to register this device.");let t=new Date().toISOString(),n=this.crypto.generateNonce(),o=await this.generateKeyId(r.publicKey),s=await this.crypto.hashSha256Base64(e.body||""),a;if(e.url.startsWith("/"))a=e.url;else try{let f=new URL(e.url);a=f.pathname+f.search}catch{a=e.url}let y=this.crypto.createPayloadV1({method:e.method,pathAndQuery:a,bodySha256:s,timestamp:t,nonce:n,apiKey:this.config.apiKey,keyId:o}),b=await this.crypto.sign(r.privateKey,y);return{"x-keyguard-api-key":this.config.apiKey,"x-keyguard-key-id":o,"x-keyguard-timestamp":t,"x-keyguard-nonce":n,"x-keyguard-body-sha256":s,"x-keyguard-alg":"ECDSA_P256_SHA256_P1363","x-keyguard-signature":b}}catch(r){throw new Error(`Request signing failed: ${r instanceof Error?r.message:"Unknown error"}`)}}async unenroll(){try{await this.storage.clear()}catch(e){throw new Error(`Unenrollment failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async isEnrolled(){try{return await this.storage.getKeyPair()!==null}catch{return!1}}async generateKeyId(e){let r=await this.crypto.exportPublicKey(e),n=new TextEncoder().encode(r),o=await crypto.subtle.digest("SHA-256",n);return Array.from(new Uint8Array(o)).slice(0,16).map(y=>y.toString(16).padStart(2,"0")).join("")}getUserAgent(){if(typeof navigator<"u"&&navigator.userAgent)return navigator.userAgent}};var K=class{constructor(){this.publicKey=null;this.privateKey=null}async saveKeyPair(e,r){this.publicKey=e,this.privateKey=r}async getKeyPair(){return!this.publicKey||!this.privateKey?null:{publicKey:this.publicKey,privateKey:this.privateKey}}async clear(){this.publicKey=null,this.privateKey=null}};export{g as BrowserStorageAdapter,p as CryptoManager,v as KeyGuardClient,K as MemoryStorageAdapter,d as arrayBufferToBase64,A as base64ToArrayBuffer};
