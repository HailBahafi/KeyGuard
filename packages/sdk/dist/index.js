"use strict";var A=Object.create;var u=Object.defineProperty;var k=Object.getOwnPropertyDescriptor;var S=Object.getOwnPropertyNames;var C=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var U=(t,e)=>{for(var r in e)u(t,r,{get:e[r],enumerable:!0})},v=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of S(e))!x.call(t,i)&&i!==r&&u(t,i,{get:()=>e[i],enumerable:!(n=k(e,i))||n.enumerable});return t};var B=(t,e,r)=>(r=t!=null?A(C(t)):{},v(e||!t||!t.__esModule?u(r,"default",{value:t,enumerable:!0}):r,t)),I=t=>v(u({},"__esModule",{value:!0}),t);var T={};U(T,{BrowserStorageAdapter:()=>f,CryptoManager:()=>d,KeyGuardClient:()=>w,MemoryStorageAdapter:()=>m,arrayBufferToBase64:()=>l,base64ToArrayBuffer:()=>K});module.exports=I(T);var D={name:"ECDSA",namedCurve:"P-256"},F={name:"ECDSA",hash:{name:"SHA-256"}},d=class{constructor(){if(typeof globalThis.crypto<"u")this.crypto=globalThis.crypto;else if(typeof window<"u"&&window.crypto)this.crypto=window.crypto;else throw new Error("WebCrypto API is not available in this environment");if(!this.crypto.subtle)throw new Error("SubtleCrypto API is not available")}async generateKeyPair(){try{let e=await this.crypto.subtle.generateKey(D,!1,["sign","verify"]);if(!e.privateKey||!e.publicKey)throw new Error("Failed to generate key pair: missing keys");return e}catch(e){throw new Error(`Key generation failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async exportPublicKey(e){try{if(e.type!=="public")throw new Error("Provided key is not a public key");let r=await this.crypto.subtle.exportKey("spki",e);return l(r)}catch(r){throw new Error(`Public key export failed: ${r instanceof Error?r.message:"Unknown error"}`)}}async sign(e,r){try{if(e.type!=="private")throw new Error("Provided key is not a private key");let i=new TextEncoder().encode(r),o=await this.crypto.subtle.sign(F,e,i);return l(o)}catch(n){throw new Error(`Signing failed: ${n instanceof Error?n.message:"Unknown error"}`)}}createPayloadV1(e){let r=e.method.toUpperCase();return`kg-v1|${e.timestamp}|${r}|${e.pathAndQuery}|${e.bodySha256}|${e.nonce}|${e.apiKey}|${e.keyId}`}async hashSha256Base64(e){let r=typeof e=="string"?new TextEncoder().encode(e):e,n=await this.crypto.subtle.digest("SHA-256",r);return l(n)}generateNonce(e=16){let r=new Uint8Array(e);return this.crypto.getRandomValues(r),l(r)}};function l(t){let e=t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength),r="";for(let n=0;n<e.length;n++)r+=String.fromCharCode(e[n]);if(typeof btoa<"u")return btoa(r);if(typeof Buffer<"u")return Buffer.from(e).toString("base64");throw new Error("No Base64 encoding method available")}function K(t){let e;if(typeof atob<"u")e=atob(t);else if(typeof Buffer<"u")e=Buffer.from(t,"base64").toString("binary");else throw new Error("No Base64 decoding method available");let r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return r.buffer}var s=require("idb-keyval"),p=(0,s.createStore)("keyguard-db","keyguard-store"),g={PUBLIC_KEY:"public-key",PRIVATE_KEY:"private-key"},f=class{async saveKeyPair(e,r){try{if(e.type!=="public")throw new Error("Invalid public key type");if(r.type!=="private")throw new Error("Invalid private key type");await(0,s.set)(g.PUBLIC_KEY,e,p),await(0,s.set)(g.PRIVATE_KEY,r,p)}catch(n){throw new Error(`Failed to save key pair: ${n instanceof Error?n.message:"Unknown error"}`)}}async getKeyPair(){try{let e=await(0,s.get)(g.PUBLIC_KEY,p),r=await(0,s.get)(g.PRIVATE_KEY,p);if(!e||!r)return null;if(e.type!=="public"||r.type!=="private")throw new Error("Retrieved keys have invalid types");return{publicKey:e,privateKey:r}}catch(e){throw new Error(`Failed to retrieve key pair: ${e instanceof Error?e.message:"Unknown error"}`)}}async clear(){try{await(0,s.del)(g.PUBLIC_KEY,p),await(0,s.del)(g.PRIVATE_KEY,p)}catch(e){throw new Error(`Failed to clear keys: ${e instanceof Error?e.message:"Unknown error"}`)}}};var b=B(require("@fingerprintjs/fingerprintjs"));async function P(){if(typeof process<"u"&&process.versions!=null&&process.versions.node!=null||typeof window>"u")return console.warn("\u26A0\uFE0F KeyGuard: Running in Node.js/Server environment - Using Mock Fingerprint"),{visitorId:"node-test-device-"+Date.now(),label:"Node.js Environment",metadata:{platform:"Node.js",userAgent:"Terminal",isServer:!0,timestamp:new Date().toISOString()}};try{let r=await(await b.default.load()).get(),n=r.components,i=R(n);return{visitorId:r.visitorId,label:i,metadata:r.components||{}}}catch(e){return console.warn("KeyGuard: FingerprintJS failed, falling back.",e),{visitorId:"fallback-"+Date.now(),label:"Unknown Device",metadata:{error:String(e)}}}}function R(t){let e=(a,c="")=>a&&typeof a=="object"&&"value"in a?a.value??c:c,r="Unknown Browser",n=String(e(t.vendor,"")),i=e(t.vendorFlavors,[]);n.includes("Google")||Array.isArray(i)&&i.includes("chrome")?r="Chrome":n.includes("Apple")||Array.isArray(i)&&i.includes("safari")?r="Safari":Array.isArray(i)&&i.includes("firefox")&&(r="Firefox");let o="Unknown OS",y=String(e(t.platform,""));return y.includes("Win")?o="Windows":y.includes("Mac")?o="macOS":y.includes("Linux")&&(o="Linux"),`${r} on ${o}`}var $={apiBaseUrl:"https://api.keyguard.dev"},w=class{constructor(e){if(!e.apiKey)throw new Error("KeyGuard SDK requires an apiKey");if(this.config={...$,...e},this.crypto=new d,this.config.storage)if(typeof this.config.storage=="string")if(this.config.storage==="browser")this.storage=new f;else throw this.config.storage==="memory"?new Error("Memory storage string shortcut not fully implemented. Pass instance of MemoryStorageAdapter instead."):new Error(`Unsupported storage type: ${this.config.storage}`);else this.storage=this.config.storage;else if(typeof window<"u"&&typeof indexedDB<"u")this.storage=new f;else throw new Error("No storage adapter provided and browser environment not detected. Please provide a custom storage adapter for Node.js environments.");this.config.fingerprintProvider&&(this.fingerprintProvider=this.config.fingerprintProvider)}async enroll(e){try{let r;if(this.fingerprintProvider?r=await this.fingerprintProvider.getFingerprint():r=await P(),await this.storage.getKeyPair())throw new Error("Device already enrolled. Call unenroll() first to re-enroll this device.");let i=await this.crypto.generateKeyPair();await this.storage.saveKeyPair(i.publicKey,i.privateKey);let o=await this.crypto.exportPublicKey(i.publicKey),y=await this.generateKeyId(i.publicKey),a=e||r.label;return{publicKey:o,keyId:y,deviceFingerprint:r.visitorId,label:a,userAgent:this.getUserAgent(),metadata:r.metadata}}catch(r){throw new Error(`Enrollment failed: ${r instanceof Error?r.message:"Unknown error"}`)}}async signRequest(e){try{let r=await this.storage.getKeyPair();if(!r)throw new Error("Device not enrolled. Call enroll() first to register this device.");let n=new Date().toISOString(),i=this.crypto.generateNonce(),o=await this.generateKeyId(r.publicKey),y=await this.crypto.hashSha256Base64(e.body||""),a;if(e.url.startsWith("/"))a=e.url;else try{let h=new URL(e.url);a=h.pathname+h.search}catch{a=e.url}let c=this.crypto.createPayloadV1({method:e.method,pathAndQuery:a,bodySha256:y,timestamp:n,nonce:i,apiKey:this.config.apiKey,keyId:o}),E=await this.crypto.sign(r.privateKey,c);return{"x-keyguard-api-key":this.config.apiKey,"x-keyguard-key-id":o,"x-keyguard-timestamp":n,"x-keyguard-nonce":i,"x-keyguard-body-sha256":y,"x-keyguard-alg":"ECDSA_P256_SHA256_P1363","x-keyguard-signature":E}}catch(r){throw new Error(`Request signing failed: ${r instanceof Error?r.message:"Unknown error"}`)}}async unenroll(){try{await this.storage.clear()}catch(e){throw new Error(`Unenrollment failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async isEnrolled(){try{return await this.storage.getKeyPair()!==null}catch{return!1}}async generateKeyId(e){let r=await this.crypto.exportPublicKey(e),i=new TextEncoder().encode(r),o=await crypto.subtle.digest("SHA-256",i);return Array.from(new Uint8Array(o)).slice(0,16).map(c=>c.toString(16).padStart(2,"0")).join("")}getUserAgent(){if(typeof navigator<"u"&&navigator.userAgent)return navigator.userAgent}};var m=class{constructor(){this.publicKey=null;this.privateKey=null}async saveKeyPair(e,r){this.publicKey=e,this.privateKey=r}async getKeyPair(){return!this.publicKey||!this.privateKey?null:{publicKey:this.publicKey,privateKey:this.privateKey}}async clear(){this.publicKey=null,this.privateKey=null}};0&&(module.exports={BrowserStorageAdapter,CryptoManager,KeyGuardClient,MemoryStorageAdapter,arrayBufferToBase64,base64ToArrayBuffer});
