{"version":3,"sources":["../src/core/crypto.ts","../src/storage/browser.ts","../src/core/fingerprint.ts","../src/client.ts"],"names":["createStore","set","get","del","FingerprintJS"],"mappings":"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","file":"index.js","sourcesContent":["/**\r\n * KeyGuard SDK - Cryptography Module\r\n * \r\n * WebCrypto API wrapper for ECDSA P-256 operations\r\n * - Key generation (non-extractable private keys)\r\n * - Signing with ECDSA-SHA256\r\n * - Public key export in SPKI format\r\n */\r\n\r\n/**\r\n * ECDSA algorithm parameters for P-256 curve with SHA-256\r\n */\r\nconst ECDSA_PARAMS: EcKeyGenParams = {\r\n  name: 'ECDSA',\r\n  namedCurve: 'P-256', // secp256r1\r\n};\r\n\r\nconst ECDSA_SIGN_PARAMS: EcdsaParams = {\r\n  name: 'ECDSA',\r\n  hash: { name: 'SHA-256' },\r\n};\r\n\r\n/**\r\n * CryptoManager - Handles all cryptographic operations for KeyGuard SDK\r\n */\r\nexport class CryptoManager {\r\n  private crypto: Crypto;\r\n\r\n  constructor() {\r\n    // Support both browser and Node.js environments\r\n    if (typeof globalThis.crypto !== 'undefined') {\r\n      this.crypto = globalThis.crypto;\r\n    } else if (typeof window !== 'undefined' && window.crypto) {\r\n      this.crypto = window.crypto;\r\n    } else {\r\n      throw new Error('WebCrypto API is not available in this environment');\r\n    }\r\n\r\n    if (!this.crypto.subtle) {\r\n      throw new Error('SubtleCrypto API is not available');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a new ECDSA P-256 key pair\r\n   * \r\n   * CRITICAL SECURITY: Private key is non-extractable (extractable: false)\r\n   * This ensures the private key cannot be exported from the CryptoKey object\r\n   * \r\n   * @returns CryptoKeyPair with public and private keys\r\n   * @throws Error if key generation fails\r\n   */\r\n  async generateKeyPair(): Promise<CryptoKeyPair> {\r\n    try {\r\n      const keyPair = await this.crypto.subtle.generateKey(\r\n        ECDSA_PARAMS,\r\n        false, // extractable: false - CRITICAL SECURITY REQUIREMENT\r\n        ['sign', 'verify']\r\n      );\r\n\r\n      if (!keyPair.privateKey || !keyPair.publicKey) {\r\n        throw new Error('Failed to generate key pair: missing keys');\r\n      }\r\n\r\n      return keyPair;\r\n    } catch (error) {\r\n      throw new Error(\r\n        `Key generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Export a public key to Base64-encoded SPKI format\r\n   * \r\n   * SPKI (SubjectPublicKeyInfo) is a standard format for public keys\r\n   * that can be transmitted and stored\r\n   * \r\n   * @param publicKey - The CryptoKey to export (must be extractable)\r\n   * @returns Base64-encoded SPKI representation\r\n   * @throws Error if export fails or key is not a public key\r\n   */\r\n  async exportPublicKey(publicKey: CryptoKey): Promise<string> {\r\n    try {\r\n      if (publicKey.type !== 'public') {\r\n        throw new Error('Provided key is not a public key');\r\n      }\r\n\r\n      const spki = await this.crypto.subtle.exportKey('spki', publicKey);\r\n      return arrayBufferToBase64(spki);\r\n    } catch (error) {\r\n      throw new Error(\r\n        `Public key export failed: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sign a payload using the private key\r\n   * \r\n   * @param privateKey - The private CryptoKey (non-extractable)\r\n   * @param payload - The string payload to sign\r\n   * @returns Base64-encoded ECDSA signature\r\n   * @throws Error if signing fails or key is not a private key\r\n   */\r\n  async sign(privateKey: CryptoKey, payload: string): Promise<string> {\r\n    try {\r\n      if (privateKey.type !== 'private') {\r\n        throw new Error('Provided key is not a private key');\r\n      }\r\n\r\n      // Encode the payload to Uint8Array\r\n      const encoder = new TextEncoder();\r\n      const data = encoder.encode(payload);\r\n\r\n      // Sign the data\r\n      const signature = await this.crypto.subtle.sign(\r\n        ECDSA_SIGN_PARAMS,\r\n        privateKey,\r\n        data\r\n      );\r\n\r\n      return arrayBufferToBase64(signature);\r\n    } catch (error) {\r\n      throw new Error(\r\n        `Signing failed: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a canonicalized payload for signing\r\n   * \r\n   * This format is CRITICAL - the backend must parse this exact format\r\n   * Format: {timestamp}|{METHOD}|{url}|{body}|{nonce}\r\n   * \r\n   * @param method - HTTP method (will be uppercased)\r\n   * @param url - Full request URL\r\n   * @param body - Request body (empty string if no body)\r\n   * @param timestamp - ISO 8601 timestamp\r\n   * @param nonce - Unique nonce for replay prevention\r\n   * @returns Canonicalized payload string\r\n   */\r\n  createPayload(\r\n    method: string,\r\n    url: string,\r\n    body: string,\r\n    timestamp: string,\r\n    nonce: string\r\n  ): string {\r\n    // Ensure method is uppercase for consistency\r\n    const normalizedMethod = method.toUpperCase();\r\n    \r\n    // Create the canonical format with pipe separator\r\n    return `${timestamp}|${normalizedMethod}|${url}|${body}|${nonce}`;\r\n  }\r\n\r\n  /**\r\n   * Generate a cryptographically secure random nonce\r\n   * \r\n   * @param length - Number of random bytes (default: 16)\r\n   * @returns Base64-encoded random nonce\r\n   */\r\n  generateNonce(length: number = 16): string {\r\n    const randomBytes = new Uint8Array(length);\r\n    this.crypto.getRandomValues(randomBytes);\r\n    return arrayBufferToBase64(randomBytes);\r\n  }\r\n}\r\n\r\n/**\r\n * Convert an ArrayBuffer to a Base64 string\r\n * \r\n * @param buffer - ArrayBuffer or ArrayBufferView to convert\r\n * @returns Base64-encoded string\r\n */\r\nexport function arrayBufferToBase64(buffer: ArrayBuffer | ArrayBufferView): string {\r\n  // Handle both ArrayBuffer and typed arrays\r\n  const bytes = buffer instanceof ArrayBuffer\r\n    ? new Uint8Array(buffer)\r\n    : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\r\n\r\n  // Convert to binary string\r\n  let binary = '';\r\n  for (let i = 0; i < bytes.length; i++) {\r\n    binary += String.fromCharCode(bytes[i]!);\r\n  }\r\n\r\n  // Encode to Base64\r\n  if (typeof btoa !== 'undefined') {\r\n    return btoa(binary);\r\n  } else if (typeof Buffer !== 'undefined') {\r\n    // Node.js environment fallback\r\n    return Buffer.from(bytes).toString('base64');\r\n  } else {\r\n    throw new Error('No Base64 encoding method available');\r\n  }\r\n}\r\n\r\n/**\r\n * Convert a Base64 string to an ArrayBuffer\r\n * \r\n * @param base64 - Base64-encoded string\r\n * @returns ArrayBuffer\r\n */\r\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\r\n  let binary: string;\r\n\r\n  if (typeof atob !== 'undefined') {\r\n    binary = atob(base64);\r\n  } else if (typeof Buffer !== 'undefined') {\r\n    // Node.js environment fallback\r\n    binary = Buffer.from(base64, 'base64').toString('binary');\r\n  } else {\r\n    throw new Error('No Base64 decoding method available');\r\n  }\r\n\r\n  const bytes = new Uint8Array(binary.length);\r\n  for (let i = 0; i < binary.length; i++) {\r\n    bytes[i] = binary.charCodeAt(i);\r\n  }\r\n\r\n  return bytes.buffer;\r\n}\r\n","/**\r\n * KeyGuard SDK - Browser Storage Adapter\r\n * \r\n * IndexedDB-based storage implementation using idb-keyval\r\n * Stores CryptoKey objects directly using structured cloning\r\n */\r\n\r\nimport { get, set, del, createStore } from 'idb-keyval';\r\nimport type { StorageAdapter } from '../types';\r\n\r\n/**\r\n * IndexedDB store configuration for KeyGuard\r\n */\r\nconst KEYGUARD_STORE = createStore('keyguard-db', 'keyguard-store');\r\n\r\n/**\r\n * Storage keys for IndexedDB\r\n */\r\nconst STORAGE_KEYS = {\r\n  PUBLIC_KEY: 'public-key',\r\n  PRIVATE_KEY: 'private-key',\r\n} as const;\r\n\r\n/**\r\n * Browser storage adapter using IndexedDB\r\n * Leverages IndexedDB's structured cloning to store CryptoKey objects directly\r\n */\r\nexport class BrowserStorageAdapter implements StorageAdapter {\r\n  /**\r\n   * Save a CryptoKey pair to IndexedDB\r\n   * \r\n   * @param publicKey - Public CryptoKey (extractable)\r\n   * @param privateKey - Private CryptoKey (non-extractable)\r\n   * @throws Error if storage operation fails\r\n   */\r\n  async saveKeyPair(publicKey: CryptoKey, privateKey: CryptoKey): Promise<void> {\r\n    try {\r\n      // Validate key types\r\n      if (publicKey.type !== 'public') {\r\n        throw new Error('Invalid public key type');\r\n      }\r\n      if (privateKey.type !== 'private') {\r\n        throw new Error('Invalid private key type');\r\n      }\r\n\r\n      // Store both keys using structured cloning\r\n      // IndexedDB can store CryptoKey objects directly, even non-extractable ones\r\n      await set(STORAGE_KEYS.PUBLIC_KEY, publicKey, KEYGUARD_STORE);\r\n      await set(STORAGE_KEYS.PRIVATE_KEY, privateKey, KEYGUARD_STORE);\r\n    } catch (error) {\r\n      throw new Error(\r\n        `Failed to save key pair: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieve the stored CryptoKey pair from IndexedDB\r\n   * \r\n   * @returns Key pair if exists, null if not found\r\n   * @throws Error if storage operation fails\r\n   */\r\n  async getKeyPair(): Promise<{ publicKey: CryptoKey; privateKey: CryptoKey } | null> {\r\n    try {\r\n      const publicKey = await get<CryptoKey>(STORAGE_KEYS.PUBLIC_KEY, KEYGUARD_STORE);\r\n      const privateKey = await get<CryptoKey>(STORAGE_KEYS.PRIVATE_KEY, KEYGUARD_STORE);\r\n\r\n      // Both keys must exist\r\n      if (!publicKey || !privateKey) {\r\n        return null;\r\n      }\r\n\r\n      // Validate retrieved keys\r\n      if (publicKey.type !== 'public' || privateKey.type !== 'private') {\r\n        throw new Error('Retrieved keys have invalid types');\r\n      }\r\n\r\n      return { publicKey, privateKey };\r\n    } catch (error) {\r\n      throw new Error(\r\n        `Failed to retrieve key pair: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all stored keys from IndexedDB\r\n   * \r\n   * @throws Error if storage operation fails\r\n   */\r\n  async clear(): Promise<void> {\r\n    try {\r\n      await del(STORAGE_KEYS.PUBLIC_KEY, KEYGUARD_STORE);\r\n      await del(STORAGE_KEYS.PRIVATE_KEY, KEYGUARD_STORE);\r\n    } catch (error) {\r\n      throw new Error(\r\n        `Failed to clear keys: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * KeyGuard SDK - Device Fingerprinting\r\n * \r\n * Professional device fingerprinting using FingerprintJS\r\n * Collects browser and device metadata for secure device identification\r\n */\r\n\r\nimport FingerprintJS from '@fingerprintjs/fingerprintjs';\r\n\r\n/**\r\n * Device fingerprint data structure\r\n */\r\nexport interface DeviceFingerprint {\r\n  /**\r\n   * Unique visitor ID (hash of device characteristics)\r\n   */\r\n  visitorId: string;\r\n\r\n  /**\r\n   * User-friendly device label (e.g., \"Chrome on macOS\")\r\n   */\r\n  label: string;\r\n\r\n  /**\r\n   * Raw fingerprint components for additional metadata\r\n   */\r\n  metadata: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Get comprehensive device fingerprint using FingerprintJS\r\n * \r\n * This function:\r\n * 1. Loads FingerprintJS library\r\n * 2. Collects device and browser characteristics\r\n * 3. Generates a unique visitor ID\r\n * 4. Creates a user-friendly label\r\n * 5. Returns fingerprint data with metadata\r\n * \r\n * @returns Device fingerprint information\r\n * @throws Error if fingerprinting fails\r\n */\r\nexport async function getDeviceFingerprint(): Promise<DeviceFingerprint> {\r\n  try {\r\n    // Load FingerprintJS agent\r\n    const fpPromise = FingerprintJS.load();\r\n    const fp = await fpPromise;\r\n\r\n    // Get comprehensive fingerprint data\r\n    const result = await fp.get();\r\n\r\n    // Extract useful components for metadata (cast to any for flexibility)\r\n    const components = result.components as any;\r\n    \r\n    // Create user-friendly label from browser and platform info\r\n    const label = generateDeviceLabel(components);\r\n\r\n    // Helper to safely extract component values\r\n    const getValue = (component: any): unknown => {\r\n      if (!component) return undefined;\r\n      if (typeof component === 'object' && 'value' in component) {\r\n        return component.value;\r\n      }\r\n      return undefined;\r\n    };\r\n\r\n    // Prepare metadata object with key device characteristics\r\n    const metadata: Record<string, unknown> = {\r\n      platform: getValue(components.platform),\r\n      vendor: getValue(components.vendor),\r\n      vendorFlavors: getValue(components.vendorFlavors),\r\n      screenResolution: getValue(components.screenResolution),\r\n      timezone: getValue(components.timezone),\r\n      languages: getValue(components.languages),\r\n      colorDepth: getValue(components.colorDepth),\r\n      deviceMemory: getValue(components.deviceMemory),\r\n      hardwareConcurrency: getValue(components.hardwareConcurrency),\r\n      touchSupport: getValue(components.touchSupport),\r\n    };\r\n\r\n    return {\r\n      visitorId: result.visitorId,\r\n      label,\r\n      metadata,\r\n    };\r\n  } catch (error) {\r\n    throw new Error(\r\n      `Device fingerprinting failed: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Generate a user-friendly device label from fingerprint components\r\n * \r\n * Creates labels like:\r\n * - \"Chrome on Windows\"\r\n * - \"Safari on macOS\"\r\n * - \"Firefox on Linux\"\r\n * \r\n * @param components - FingerprintJS components\r\n * @returns User-friendly device label\r\n */\r\nfunction generateDeviceLabel(components: any): string {\r\n  // Helper to safely get component value\r\n  const getValue = (component: any, fallback: any = ''): any => {\r\n    if (!component) return fallback;\r\n    if (typeof component === 'object' && 'value' in component) {\r\n      return component.value ?? fallback;\r\n    }\r\n    return fallback;\r\n  };\r\n\r\n  // Extract browser name from vendor/vendorFlavors\r\n  let browser = 'Unknown Browser';\r\n  const vendor = String(getValue(components.vendor, ''));\r\n  const vendorFlavors = getValue(components.vendorFlavors, []);\r\n  \r\n  if (vendor.includes('Google') || (Array.isArray(vendorFlavors) && vendorFlavors.includes('chrome'))) {\r\n    browser = 'Chrome';\r\n  } else if (vendor.includes('Apple') || (Array.isArray(vendorFlavors) && vendorFlavors.includes('safari'))) {\r\n    browser = 'Safari';\r\n  } else if (Array.isArray(vendorFlavors) && vendorFlavors.includes('firefox')) {\r\n    browser = 'Firefox';\r\n  } else if (Array.isArray(vendorFlavors) && vendorFlavors.includes('edge')) {\r\n    browser = 'Edge';\r\n  }\r\n\r\n  // Extract OS/Platform\r\n  let os = 'Unknown OS';\r\n  const platform = String(getValue(components.platform, ''));\r\n  \r\n  if (platform.includes('Win')) {\r\n    os = 'Windows';\r\n  } else if (platform.includes('Mac')) {\r\n    os = 'macOS';\r\n  } else if (platform.includes('Linux')) {\r\n    os = 'Linux';\r\n  } else if (platform.includes('iPhone') || platform.includes('iPad')) {\r\n    os = 'iOS';\r\n  } else if (platform.includes('Android')) {\r\n    os = 'Android';\r\n  }\r\n\r\n  // Fallback to user agent if platform detection fails\r\n  if (os === 'Unknown OS' && typeof navigator !== 'undefined') {\r\n    const ua = navigator.userAgent || '';\r\n    if (ua.includes('Windows')) os = 'Windows';\r\n    else if (ua.includes('Mac')) os = 'macOS';\r\n    else if (ua.includes('Linux')) os = 'Linux';\r\n    else if (ua.includes('iPhone') || ua.includes('iPad')) os = 'iOS';\r\n    else if (ua.includes('Android')) os = 'Android';\r\n  }\r\n\r\n  return `${browser} on ${os}`;\r\n}\r\n","/**\r\n * KeyGuard SDK - Main Client\r\n * \r\n * Secure Device Binding SDK for protecting LLM API keys\r\n */\r\n\r\nimport type { KeyGuardConfig, EnrollmentPayload, SignedRequestHeaders, StorageAdapter } from './types';\r\nimport { CryptoManager } from './core/crypto';\r\nimport { BrowserStorageAdapter } from './storage/browser';\r\nimport { getDeviceFingerprint } from './core/fingerprint';\r\n\r\n/**\r\n * Default configuration values\r\n */\r\nconst DEFAULT_CONFIG = {\r\n  apiBaseUrl: 'https://api.keyguard.dev',\r\n  storage: 'browser' as const,\r\n};\r\n\r\n/**\r\n * KeyGuard Client - Main SDK interface\r\n * \r\n * Provides device binding capabilities for securing LLM API keys\r\n */\r\nexport class KeyGuardClient {\r\n  private config: Required<KeyGuardConfig>;\r\n  private crypto: CryptoManager;\r\n  private storage: StorageAdapter;\r\n\r\n  /**\r\n   * Create a new KeyGuard client instance\r\n   * \r\n   * @param config - SDK configuration\r\n   * @throws Error if configuration is invalid or storage is unavailable\r\n   */\r\n  constructor(config: KeyGuardConfig) {\r\n    // Merge with defaults\r\n    this.config = {\r\n      ...DEFAULT_CONFIG,\r\n      ...config,\r\n    };\r\n\r\n    // Initialize crypto manager\r\n    this.crypto = new CryptoManager();\r\n\r\n    // Initialize storage adapter based on configuration\r\n    if (this.config.storage === 'browser') {\r\n      this.storage = new BrowserStorageAdapter();\r\n    } else {\r\n      throw new Error(`Unsupported storage type: ${this.config.storage}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enroll this device by generating and storing a cryptographic key pair\r\n   * \r\n   * This method:\r\n   * 1. Collects device fingerprint using FingerprintJS\r\n   * 2. Checks if device is already enrolled\r\n   * 3. Generates a new ECDSA P-256 key pair\r\n   * 4. Stores the keys securely\r\n   * 5. Exports the public key\r\n   * 6. Returns enrollment payload for backend registration\r\n   * \r\n   * @param deviceName - Optional user-friendly device label (e.g., \"Ahmed's MacBook\")\r\n   *                    If not provided, auto-generates from device info (e.g., \"Chrome on macOS\")\r\n   * @returns Enrollment payload to send to backend\r\n   * @throws Error if device is already enrolled or enrollment fails\r\n   */\r\n  async enroll(deviceName?: string): Promise<EnrollmentPayload> {\r\n    try {\r\n      // Collect device fingerprint using FingerprintJS\r\n      const fingerprint = await getDeviceFingerprint();\r\n\r\n      // Check if device is already enrolled\r\n      const existingKeys = await this.storage.getKeyPair();\r\n      if (existingKeys) {\r\n        throw new Error(\r\n          'Device already enrolled. Call unenroll() first to re-enroll this device.'\r\n        );\r\n      }\r\n\r\n      // Generate new cryptographic key pair\r\n      const keyPair = await this.crypto.generateKeyPair();\r\n\r\n      // Store keys securely\r\n      await this.storage.saveKeyPair(keyPair.publicKey, keyPair.privateKey);\r\n\r\n      // Export public key in SPKI format\r\n      const publicKeyBase64 = await this.crypto.exportPublicKey(keyPair.publicKey);\r\n\r\n      // Use provided device name or fallback to auto-generated label\r\n      const label = deviceName || fingerprint.label;\r\n\r\n      // Create enrollment payload with FingerprintJS data\r\n      const enrollmentPayload: EnrollmentPayload = {\r\n        publicKey: publicKeyBase64,\r\n        deviceFingerprint: fingerprint.visitorId,\r\n        label,\r\n        userAgent: this.getUserAgent(),\r\n        metadata: fingerprint.metadata,\r\n      };\r\n\r\n      return enrollmentPayload;\r\n    } catch (error) {\r\n      throw new Error(\r\n        `Enrollment failed: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sign an HTTP request with device credentials\r\n   * \r\n   * This method:\r\n   * 1. Retrieves stored cryptographic keys\r\n   * 2. Generates timestamp and nonce\r\n   * 3. Creates canonical payload string\r\n   * 4. Signs the payload with private key\r\n   * 5. Returns headers to attach to the request\r\n   * \r\n   * @param request - Request details to sign\r\n   * @returns Signed request headers to attach to HTTP request\r\n   * @throws Error if device is not enrolled or signing fails\r\n   */\r\n  async signRequest(request: {\r\n    method: string;\r\n    url: string;\r\n    body?: string;\r\n  }): Promise<SignedRequestHeaders> {\r\n    try {\r\n      // Retrieve stored keys\r\n      const keyPair = await this.storage.getKeyPair();\r\n      if (!keyPair) {\r\n        throw new Error(\r\n          'Device not enrolled. Call enroll() first to register this device.'\r\n        );\r\n      }\r\n\r\n      // Generate timestamp (ISO 8601 format)\r\n      const timestamp = new Date().toISOString();\r\n\r\n      // Generate cryptographically secure nonce\r\n      const nonce = this.crypto.generateNonce();\r\n\r\n      // Create canonical payload string\r\n      const payload = this.crypto.createPayload(\r\n        request.method,\r\n        request.url,\r\n        request.body || '',\r\n        timestamp,\r\n        nonce\r\n      );\r\n\r\n      // Sign the payload\r\n      const signature = await this.crypto.sign(keyPair.privateKey, payload);\r\n\r\n      // Generate key ID from public key\r\n      const keyId = await this.generateKeyId(keyPair.publicKey);\r\n\r\n      // Return signed headers\r\n      const headers: SignedRequestHeaders = {\r\n        'X-KeyGuard-Signature': signature,\r\n        'X-KeyGuard-Timestamp': timestamp,\r\n        'X-KeyGuard-Nonce': nonce,\r\n        'X-KeyGuard-Key-ID': keyId,\r\n      };\r\n\r\n      return headers;\r\n    } catch (error) {\r\n      throw new Error(\r\n        `Request signing failed: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unenroll this device by clearing all stored keys\r\n   * \r\n   * @throws Error if clearing keys fails\r\n   */\r\n  async unenroll(): Promise<void> {\r\n    try {\r\n      await this.storage.clear();\r\n    } catch (error) {\r\n      throw new Error(\r\n        `Unenrollment failed: ${error instanceof Error ? error.message : 'Unknown error'}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if this device is enrolled\r\n   * \r\n   * @returns true if device has stored keys, false otherwise\r\n   */\r\n  async isEnrolled(): Promise<boolean> {\r\n    try {\r\n      const keyPair = await this.storage.getKeyPair();\r\n      return keyPair !== null;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Generate a unique key ID from the public key\r\n   * \r\n   * @param publicKey - Public CryptoKey\r\n   * @returns Key identifier (hash of public key)\r\n   */\r\n  private async generateKeyId(publicKey: CryptoKey): Promise<string> {\r\n    // Export public key\r\n    const publicKeyBase64 = await this.crypto.exportPublicKey(publicKey);\r\n    \r\n    // Hash the public key to create a unique identifier\r\n    const encoder = new TextEncoder();\r\n    const data = encoder.encode(publicKeyBase64);\r\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\r\n    \r\n    // Convert to hex string (first 16 bytes for shorter ID)\r\n    const hashArray = Array.from(new Uint8Array(hashBuffer)).slice(0, 16);\r\n    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\r\n    \r\n    return hashHex;\r\n  }\r\n\r\n  /**\r\n   * Get the user agent string\r\n   * \r\n   * @returns User agent or undefined\r\n   */\r\n  private getUserAgent(): string | undefined {\r\n    if (typeof navigator !== 'undefined' && navigator.userAgent) {\r\n      return navigator.userAgent;\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n"]}