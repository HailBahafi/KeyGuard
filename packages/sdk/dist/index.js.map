{"version":3,"sources":["../src/core/crypto.ts","../src/storage/browser.ts","../src/core/fingerprint.ts","../src/client.ts","../src/storage/memory.ts"],"names":["createStore","set","get","del","FingerprintJS"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * KeyGuard SDK - Cryptography Module\n * \n * WebCrypto API wrapper for ECDSA P-256 operations\n * - Key generation (non-extractable private keys)\n * - Signing with ECDSA-SHA256\n * - Public key export in SPKI format\n */\n\n/**\n * ECDSA algorithm parameters for P-256 curve with SHA-256\n */\nconst ECDSA_PARAMS: EcKeyGenParams = {\n  name: 'ECDSA',\n  namedCurve: 'P-256', // secp256r1\n};\n\nconst ECDSA_SIGN_PARAMS: EcdsaParams = {\n  name: 'ECDSA',\n  hash: { name: 'SHA-256' },\n};\n\n/**\n * CryptoManager - Handles all cryptographic operations for KeyGuard SDK\n */\nexport class CryptoManager {\n  private crypto: Crypto;\n\n  constructor() {\n    // Support both browser and Node.js environments\n    if (typeof globalThis.crypto !== 'undefined') {\n      this.crypto = globalThis.crypto;\n    } else if (typeof window !== 'undefined' && window.crypto) {\n      this.crypto = window.crypto;\n    } else {\n      // In Node 19+, globalThis.crypto is available. For older versions, user might need polyfill.\n      // We throw if not available.\n      throw new Error('WebCrypto API is not available in this environment');\n    }\n\n    if (!this.crypto.subtle) {\n      throw new Error('SubtleCrypto API is not available');\n    }\n  }\n\n  /**\n   * Generate a new ECDSA P-256 key pair\n   * \n   * CRITICAL SECURITY: Private key is non-extractable (extractable: false)\n   * This ensures the private key cannot be exported from the CryptoKey object\n   * \n   * @returns CryptoKeyPair with public and private keys\n   * @throws Error if key generation fails\n   */\n  async generateKeyPair(): Promise<CryptoKeyPair> {\n    try {\n      const keyPair = await this.crypto.subtle.generateKey(\n        ECDSA_PARAMS,\n        false, // extractable: false - CRITICAL SECURITY REQUIREMENT\n        ['sign', 'verify']\n      );\n\n      if (!keyPair.privateKey || !keyPair.publicKey) {\n        throw new Error('Failed to generate key pair: missing keys');\n      }\n\n      return keyPair;\n    } catch (error) {\n      throw new Error(\n        `Key generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Export a public key to Base64-encoded SPKI format\n   * \n   * SPKI (SubjectPublicKeyInfo) is a standard format for public keys\n   * that can be transmitted and stored\n   * \n   * @param publicKey - The CryptoKey to export (must be extractable)\n   * @returns Base64-encoded SPKI representation\n   * @throws Error if export fails or key is not a public key\n   */\n  async exportPublicKey(publicKey: CryptoKey): Promise<string> {\n    try {\n      if (publicKey.type !== 'public') {\n        throw new Error('Provided key is not a public key');\n      }\n\n      const spki = await this.crypto.subtle.exportKey('spki', publicKey);\n      return arrayBufferToBase64(spki);\n    } catch (error) {\n      throw new Error(\n        `Public key export failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Sign a payload using the private key\n   * \n   * @param privateKey - The private CryptoKey (non-extractable)\n   * @param payload - The string payload to sign\n   * @returns Base64-encoded ECDSA signature (IEEE P1363 format)\n   * @throws Error if signing fails or key is not a private key\n   */\n  async sign(privateKey: CryptoKey, payload: string): Promise<string> {\n    try {\n      if (privateKey.type !== 'private') {\n        throw new Error('Provided key is not a private key');\n      }\n\n      // Encode the payload to Uint8Array\n      const encoder = new TextEncoder();\n      const data = encoder.encode(payload);\n\n      // Sign the data\n      const signature = await this.crypto.subtle.sign(\n        ECDSA_SIGN_PARAMS,\n        privateKey,\n        data\n      );\n\n      return arrayBufferToBase64(signature);\n    } catch (error) {\n      throw new Error(\n        `Signing failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Create a canonicalized payload for signing (V1 Protocol)\n   * \n   * Format: kg-v1|{timestamp}|{METHOD}|{pathAndQuery}|{bodySha256}|{nonce}|{apiKey}|{keyId}\n   * \n   * @param params - Payload parameters\n   * @returns Canonicalized payload string\n   */\n  createPayloadV1(params: {\n    method: string;\n    pathAndQuery: string;\n    bodySha256: string;\n    timestamp: string;\n    nonce: string;\n    apiKey: string;\n    keyId: string;\n  }): string {\n    // Ensure method is uppercase for consistency\n    const normalizedMethod = params.method.toUpperCase();\n\n    // Create the canonical format with pipe separator\n    // Protocol version prefix allows future upgrades\n    return `kg-v1|${params.timestamp}|${normalizedMethod}|${params.pathAndQuery}|${params.bodySha256}|${params.nonce}|${params.apiKey}|${params.keyId}`;\n  }\n\n  /**\n   * Calculate SHA-256 hash of data and return as Base64\n   * \n   * @param input - Data to hash (string or Uint8Array)\n   * @returns Base64 encoded SHA-256 hash\n   */\n  async hashSha256Base64(input: string | Uint8Array): Promise<string> {\n    const data = typeof input === 'string' ? new TextEncoder().encode(input) : input;\n    const hashBuffer = await this.crypto.subtle.digest('SHA-256', data as any);\n    return arrayBufferToBase64(hashBuffer);\n  }\n\n  /**\n   * Generate a cryptographically secure random nonce\n   * \n   * @param length - Number of random bytes (default: 16)\n   * @returns Base64-encoded random nonce\n   */\n  generateNonce(length: number = 16): string {\n    const randomBytes = new Uint8Array(length);\n    this.crypto.getRandomValues(randomBytes as any);\n    return arrayBufferToBase64(randomBytes);\n  }\n}\n\n/**\n * Convert an ArrayBuffer to a Base64 string\n * \n * @param buffer - ArrayBuffer or ArrayBufferView to convert\n * @returns Base64-encoded string\n */\nexport function arrayBufferToBase64(buffer: ArrayBuffer | ArrayBufferView): string {\n  // Handle both ArrayBuffer and typed arrays\n  const bytes = buffer instanceof ArrayBuffer\n    ? new Uint8Array(buffer)\n    : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n\n  // Convert to binary string\n  let binary = '';\n  for (let i = 0; i < bytes.length; i++) {\n    binary += String.fromCharCode(bytes[i]!);\n  }\n\n  // Encode to Base64\n  if (typeof btoa !== 'undefined') {\n    return btoa(binary);\n  } else if (typeof Buffer !== 'undefined') {\n    // Node.js environment fallback\n    return Buffer.from(bytes).toString('base64');\n  } else {\n    throw new Error('No Base64 encoding method available');\n  }\n}\n\n/**\n * Convert a Base64 string to an ArrayBuffer\n * \n * @param base64 - Base64-encoded string\n * @returns ArrayBuffer\n */\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  let binary: string;\n\n  if (typeof atob !== 'undefined') {\n    binary = atob(base64);\n  } else if (typeof Buffer !== 'undefined') {\n    // Node.js environment fallback\n    binary = Buffer.from(base64, 'base64').toString('binary');\n  } else {\n    throw new Error('No Base64 decoding method available');\n  }\n\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n\n  return bytes.buffer;\n}\n","/**\n * KeyGuard SDK - Browser Storage Adapter\n * \n * IndexedDB-based storage implementation using idb-keyval\n * Stores CryptoKey objects directly using structured cloning\n */\n\nimport { get, set, del, createStore } from 'idb-keyval';\nimport type { StorageAdapter } from '../types';\n\n/**\n * IndexedDB store configuration for KeyGuard\n */\nconst KEYGUARD_STORE = createStore('keyguard-db', 'keyguard-store');\n\n/**\n * Storage keys for IndexedDB\n */\nconst STORAGE_KEYS = {\n  PUBLIC_KEY: 'public-key',\n  PRIVATE_KEY: 'private-key',\n} as const;\n\n/**\n * Browser storage adapter using IndexedDB\n * Leverages IndexedDB's structured cloning to store CryptoKey objects directly\n */\nexport class BrowserStorageAdapter implements StorageAdapter {\n  /**\n   * Save a CryptoKey pair to IndexedDB\n   * \n   * @param publicKey - Public CryptoKey (extractable)\n   * @param privateKey - Private CryptoKey (non-extractable)\n   * @throws Error if storage operation fails\n   */\n  async saveKeyPair(publicKey: CryptoKey, privateKey: CryptoKey): Promise<void> {\n    try {\n      // Validate key types\n      if (publicKey.type !== 'public') {\n        throw new Error('Invalid public key type');\n      }\n      if (privateKey.type !== 'private') {\n        throw new Error('Invalid private key type');\n      }\n\n      // Store both keys using structured cloning\n      // IndexedDB can store CryptoKey objects directly, even non-extractable ones\n      await set(STORAGE_KEYS.PUBLIC_KEY, publicKey, KEYGUARD_STORE);\n      await set(STORAGE_KEYS.PRIVATE_KEY, privateKey, KEYGUARD_STORE);\n    } catch (error) {\n      throw new Error(\n        `Failed to save key pair: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Retrieve the stored CryptoKey pair from IndexedDB\n   * \n   * @returns Key pair if exists, null if not found\n   * @throws Error if storage operation fails\n   */\n  async getKeyPair(): Promise<{ publicKey: CryptoKey; privateKey: CryptoKey } | null> {\n    try {\n      const publicKey = await get<CryptoKey>(STORAGE_KEYS.PUBLIC_KEY, KEYGUARD_STORE);\n      const privateKey = await get<CryptoKey>(STORAGE_KEYS.PRIVATE_KEY, KEYGUARD_STORE);\n\n      // Both keys must exist\n      if (!publicKey || !privateKey) {\n        return null;\n      }\n\n      // Validate retrieved keys\n      if (publicKey.type !== 'public' || privateKey.type !== 'private') {\n        throw new Error('Retrieved keys have invalid types');\n      }\n\n      return { publicKey, privateKey };\n    } catch (error) {\n      throw new Error(\n        `Failed to retrieve key pair: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Clear all stored keys from IndexedDB\n   * \n   * @throws Error if storage operation fails\n   */\n  async clear(): Promise<void> {\n    try {\n      await del(STORAGE_KEYS.PUBLIC_KEY, KEYGUARD_STORE);\n      await del(STORAGE_KEYS.PRIVATE_KEY, KEYGUARD_STORE);\n    } catch (error) {\n      throw new Error(\n        `Failed to clear keys: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n}\n","/**\n * KeyGuard SDK - Device Fingerprinting\n * \n * Professional device fingerprinting using FingerprintJS\n * Collects browser and device metadata for secure device identification\n */\n\nimport FingerprintJS from '@fingerprintjs/fingerprintjs';\n\n/**\n * Device fingerprint data structure\n */\nexport interface DeviceFingerprint {\n  /**\n   * Unique visitor ID (hash of device characteristics)\n   */\n  visitorId: string;\n\n  /**\n   * User-friendly device label (e.g., \"Chrome on macOS\")\n   */\n  label: string;\n\n  /**\n   * Raw fingerprint components for additional metadata\n   */\n  metadata: Record<string, unknown>;\n}\n\n/**\n * Get comprehensive device fingerprint using FingerprintJS\n * \n * This function:\n * 1. Loads FingerprintJS library\n * 2. Collects device and browser characteristics\n * 3. Generates a unique visitor ID\n * 4. Creates a user-friendly label\n * 5. Returns fingerprint data with metadata\n * \n * @returns Device fingerprint information\n * @throws Error if fingerprinting fails\n */\nexport async function getDeviceFingerprint(): Promise<DeviceFingerprint> {\n  try {\n    // Load FingerprintJS agent\n    const fpPromise = FingerprintJS.load();\n    const fp = await fpPromise;\n\n    // Get comprehensive fingerprint data\n    const result = await fp.get();\n\n    // Extract useful components for metadata (cast to any for flexibility)\n    const components = result.components as any;\n    \n    // Create user-friendly label from browser and platform info\n    const label = generateDeviceLabel(components);\n\n    // Helper to safely extract component values\n    const getValue = (component: any): unknown => {\n      if (!component) return undefined;\n      if (typeof component === 'object' && 'value' in component) {\n        return component.value;\n      }\n      return undefined;\n    };\n\n    // Prepare metadata object with key device characteristics\n    const metadata: Record<string, unknown> = {\n      platform: getValue(components.platform),\n      vendor: getValue(components.vendor),\n      vendorFlavors: getValue(components.vendorFlavors),\n      screenResolution: getValue(components.screenResolution),\n      timezone: getValue(components.timezone),\n      languages: getValue(components.languages),\n      colorDepth: getValue(components.colorDepth),\n      deviceMemory: getValue(components.deviceMemory),\n      hardwareConcurrency: getValue(components.hardwareConcurrency),\n      touchSupport: getValue(components.touchSupport),\n    };\n\n    return {\n      visitorId: result.visitorId,\n      label,\n      metadata,\n    };\n  } catch (error) {\n    throw new Error(\n      `Device fingerprinting failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n    );\n  }\n}\n\n/**\n * Generate a user-friendly device label from fingerprint components\n * \n * Creates labels like:\n * - \"Chrome on Windows\"\n * - \"Safari on macOS\"\n * - \"Firefox on Linux\"\n * \n * @param components - FingerprintJS components\n * @returns User-friendly device label\n */\nfunction generateDeviceLabel(components: any): string {\n  // Helper to safely get component value\n  const getValue = (component: any, fallback: any = ''): any => {\n    if (!component) return fallback;\n    if (typeof component === 'object' && 'value' in component) {\n      return component.value ?? fallback;\n    }\n    return fallback;\n  };\n\n  // Extract browser name from vendor/vendorFlavors\n  let browser = 'Unknown Browser';\n  const vendor = String(getValue(components.vendor, ''));\n  const vendorFlavors = getValue(components.vendorFlavors, []);\n  \n  if (vendor.includes('Google') || (Array.isArray(vendorFlavors) && vendorFlavors.includes('chrome'))) {\n    browser = 'Chrome';\n  } else if (vendor.includes('Apple') || (Array.isArray(vendorFlavors) && vendorFlavors.includes('safari'))) {\n    browser = 'Safari';\n  } else if (Array.isArray(vendorFlavors) && vendorFlavors.includes('firefox')) {\n    browser = 'Firefox';\n  } else if (Array.isArray(vendorFlavors) && vendorFlavors.includes('edge')) {\n    browser = 'Edge';\n  }\n\n  // Extract OS/Platform\n  let os = 'Unknown OS';\n  const platform = String(getValue(components.platform, ''));\n  \n  if (platform.includes('Win')) {\n    os = 'Windows';\n  } else if (platform.includes('Mac')) {\n    os = 'macOS';\n  } else if (platform.includes('Linux')) {\n    os = 'Linux';\n  } else if (platform.includes('iPhone') || platform.includes('iPad')) {\n    os = 'iOS';\n  } else if (platform.includes('Android')) {\n    os = 'Android';\n  }\n\n  // Fallback to user agent if platform detection fails\n  if (os === 'Unknown OS' && typeof navigator !== 'undefined') {\n    const ua = navigator.userAgent || '';\n    if (ua.includes('Windows')) os = 'Windows';\n    else if (ua.includes('Mac')) os = 'macOS';\n    else if (ua.includes('Linux')) os = 'Linux';\n    else if (ua.includes('iPhone') || ua.includes('iPad')) os = 'iOS';\n    else if (ua.includes('Android')) os = 'Android';\n  }\n\n  return `${browser} on ${os}`;\n}\n","/**\n * KeyGuard SDK - Main Client\n * \n * Secure Device Binding SDK for protecting LLM API keys\n */\n\nimport type { KeyGuardConfig, EnrollmentPayload, SignedRequestHeaders, StorageAdapter, FingerprintProvider } from './types';\nimport { CryptoManager } from './core/crypto';\nimport { BrowserStorageAdapter } from './storage/browser';\nimport { getDeviceFingerprint } from './core/fingerprint';\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG = {\n  apiBaseUrl: 'https://api.keyguard.dev',\n};\n\n/**\n * KeyGuard Client - Main SDK interface\n * \n * Provides device binding capabilities for securing LLM API keys\n */\nexport class KeyGuardClient {\n  private config: KeyGuardConfig;\n  private crypto: CryptoManager;\n  private storage: StorageAdapter;\n  private fingerprintProvider?: FingerprintProvider;\n\n  /**\n   * Create a new KeyGuard client instance\n   * \n   * @param config - SDK configuration\n   * @throws Error if configuration is invalid or storage is unavailable\n   */\n  constructor(config: KeyGuardConfig) {\n    if (!config.apiKey) {\n      throw new Error('KeyGuard SDK requires an apiKey');\n    }\n\n    // Merge with defaults\n    this.config = {\n      ...DEFAULT_CONFIG,\n      ...config,\n    };\n\n    // Initialize crypto manager\n    this.crypto = new CryptoManager();\n\n    // Initialize storage adapter\n    if (this.config.storage) {\n      if (typeof this.config.storage === 'string') {\n        if (this.config.storage === 'browser') {\n          this.storage = new BrowserStorageAdapter();\n        } else if (this.config.storage === 'memory') {\n          // Dynamic import to avoid bundling memory adapter if not needed, \n          // but for now we'll assume it's available or user passes instance\n          throw new Error('Memory storage string shortcut not fully implemented. Pass instance of MemoryStorageAdapter instead.');\n        } else {\n          throw new Error(`Unsupported storage type: ${this.config.storage}`);\n        }\n      } else {\n        // User provided adapter instance\n        this.storage = this.config.storage;\n      }\n    } else {\n      // Default to browser storage\n      if (typeof window !== 'undefined' && typeof indexedDB !== 'undefined') {\n        this.storage = new BrowserStorageAdapter();\n      } else {\n        throw new Error('No storage adapter provided and browser environment not detected. Please provide a custom storage adapter for Node.js environments.');\n      }\n    }\n\n    // Initialize fingerprint provider\n    if (this.config.fingerprintProvider) {\n      this.fingerprintProvider = this.config.fingerprintProvider;\n    }\n  }\n\n  /**\n   * Enroll this device by generating and storing a cryptographic key pair\n   * \n   * This method:\n   * 1. Collects device fingerprint\n   * 2. Checks if device is already enrolled\n   * 3. Generates a new ECDSA P-256 key pair\n   * 4. Stores the keys securely\n   * 5. Exports the public key\n   * 6. Returns enrollment payload for backend registration\n   * \n   * @param deviceName - Optional user-friendly device label\n   * @returns Enrollment payload to send to backend\n   * @throws Error if device is already enrolled or enrollment fails\n   */\n  async enroll(deviceName?: string): Promise<EnrollmentPayload> {\n    try {\n      // Collect device fingerprint\n      let fingerprint;\n      if (this.fingerprintProvider) {\n        fingerprint = await this.fingerprintProvider.getFingerprint();\n      } else if (typeof window !== 'undefined') {\n        fingerprint = await getDeviceFingerprint();\n      } else {\n        throw new Error('No fingerprint provider configured and browser environment not detected.');\n      }\n\n      // Check if device is already enrolled\n      const existingKeys = await this.storage.getKeyPair();\n      if (existingKeys) {\n        throw new Error(\n          'Device already enrolled. Call unenroll() first to re-enroll this device.'\n        );\n      }\n\n      // Generate new cryptographic key pair\n      const keyPair = await this.crypto.generateKeyPair();\n\n      // Store keys securely\n      await this.storage.saveKeyPair(keyPair.publicKey, keyPair.privateKey);\n\n      // Export public key in SPKI format\n      const publicKeyBase64 = await this.crypto.exportPublicKey(keyPair.publicKey);\n\n      // Generate Key ID\n      const keyId = await this.generateKeyId(keyPair.publicKey);\n\n      // Use provided device name or fallback to auto-generated label\n      const label = deviceName || fingerprint.label;\n\n      // Create enrollment payload\n      const enrollmentPayload: EnrollmentPayload = {\n        publicKey: publicKeyBase64,\n        keyId,\n        deviceFingerprint: fingerprint.visitorId,\n        label,\n        userAgent: this.getUserAgent(),\n        metadata: fingerprint.metadata,\n      };\n\n      return enrollmentPayload;\n    } catch (error) {\n      throw new Error(\n        `Enrollment failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Sign an HTTP request with device credentials\n   * \n   * This method:\n   * 1. Retrieves stored cryptographic keys\n   * 2. Generates timestamp and nonce\n   * 3. Calculates body hash\n   * 4. Creates canonical payload string (V1)\n   * 5. Signs the payload with private key\n   * 6. Returns headers to attach to the request\n   * \n   * @param request - Request details to sign\n   * @returns Signed request headers to attach to HTTP request\n   * @throws Error if device is not enrolled or signing fails\n   */\n  async signRequest(request: {\n    method: string;\n    url: string;\n    body?: string;\n  }): Promise<SignedRequestHeaders> {\n    try {\n      // Retrieve stored keys\n      const keyPair = await this.storage.getKeyPair();\n      if (!keyPair) {\n        throw new Error(\n          'Device not enrolled. Call enroll() first to register this device.'\n        );\n      }\n\n      // Generate timestamp (ISO 8601 format)\n      const timestamp = new Date().toISOString();\n\n      // Generate cryptographically secure nonce\n      const nonce = this.crypto.generateNonce();\n\n      // Generate Key ID\n      const keyId = await this.generateKeyId(keyPair.publicKey);\n\n      // Calculate Body Hash (SHA-256)\n      const bodySha256 = await this.crypto.hashSha256Base64(request.body || '');\n\n      // Parse URL to get path + query\n      let pathAndQuery: string;\n      if (request.url.startsWith('/')) {\n        pathAndQuery = request.url;\n      } else {\n        try {\n          const urlObj = new URL(request.url);\n          pathAndQuery = urlObj.pathname + urlObj.search;\n        } catch (e) {\n          // Fallback if URL parsing fails (e.g. relative URL without base)\n          pathAndQuery = request.url;\n        }\n      }\n\n      // Create canonical payload string (V1)\n      const payload = this.crypto.createPayloadV1({\n        method: request.method,\n        pathAndQuery,\n        bodySha256,\n        timestamp,\n        nonce,\n        apiKey: this.config.apiKey,\n        keyId\n      });\n\n      // Sign the payload\n      const signature = await this.crypto.sign(keyPair.privateKey, payload);\n\n      // Return signed headers\n      const headers: SignedRequestHeaders = {\n        'x-keyguard-api-key': this.config.apiKey,\n        'x-keyguard-key-id': keyId,\n        'x-keyguard-timestamp': timestamp,\n        'x-keyguard-nonce': nonce,\n        'x-keyguard-body-sha256': bodySha256,\n        'x-keyguard-alg': 'ECDSA_P256_SHA256_P1363',\n        'x-keyguard-signature': signature,\n      };\n\n      return headers;\n    } catch (error) {\n      throw new Error(\n        `Request signing failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Unenroll this device by clearing all stored keys\n   * \n   * @throws Error if clearing keys fails\n   */\n  async unenroll(): Promise<void> {\n    try {\n      await this.storage.clear();\n    } catch (error) {\n      throw new Error(\n        `Unenrollment failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Check if this device is enrolled\n   * \n   * @returns true if device has stored keys, false otherwise\n   */\n  async isEnrolled(): Promise<boolean> {\n    try {\n      const keyPair = await this.storage.getKeyPair();\n      return keyPair !== null;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Generate a unique key ID from the public key\n   * \n   * @param publicKey - Public CryptoKey\n   * @returns Key identifier (hash of public key)\n   */\n  private async generateKeyId(publicKey: CryptoKey): Promise<string> {\n    // Export public key\n    const publicKeyBase64 = await this.crypto.exportPublicKey(publicKey);\n\n    // Hash the public key to create a unique identifier\n    const encoder = new TextEncoder();\n    const data = encoder.encode(publicKeyBase64);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n\n    // Convert to hex string (first 16 bytes for shorter ID)\n    const hashArray = Array.from(new Uint8Array(hashBuffer)).slice(0, 16);\n    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n\n    return hashHex;\n  }\n\n  /**\n   * Get the user agent string\n   * \n   * @returns User agent or undefined\n   */\n  private getUserAgent(): string | undefined {\n    if (typeof navigator !== 'undefined' && navigator.userAgent) {\n      return navigator.userAgent;\n    }\n    return undefined;\n  }\n}\n","/**\n * KeyGuard SDK - Memory Storage Adapter\n * \n * In-memory storage implementation for testing or non-persistent environments\n */\n\nimport type { StorageAdapter } from '../types';\n\nexport class MemoryStorageAdapter implements StorageAdapter {\n    private publicKey: CryptoKey | null = null;\n    private privateKey: CryptoKey | null = null;\n\n    async saveKeyPair(publicKey: CryptoKey, privateKey: CryptoKey): Promise<void> {\n        this.publicKey = publicKey;\n        this.privateKey = privateKey;\n    }\n\n    async getKeyPair(): Promise<{ publicKey: CryptoKey; privateKey: CryptoKey } | null> {\n        if (!this.publicKey || !this.privateKey) {\n            return null;\n        }\n        return {\n            publicKey: this.publicKey,\n            privateKey: this.privateKey\n        };\n    }\n\n    async clear(): Promise<void> {\n        this.publicKey = null;\n        this.privateKey = null;\n    }\n}\n"]}