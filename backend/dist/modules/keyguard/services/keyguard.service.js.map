{"version":3,"sources":["../../../../src/modules/keyguard/services/keyguard.service.ts"],"sourcesContent":["import {\n  Injectable,\n  Logger,\n  BadRequestException,\n  UnauthorizedException,\n  NotFoundException,\n} from '@nestjs/common';\nimport { PrismaService } from '@/src/core/database/prisma.service';\nimport { SignatureVerificationService } from './signature-verification.service';\nimport {\n  EnrollDeviceDto,\n  EnrollResponseDto,\n  VerifyResponseDto,\n  KeyGuardHeaders,\n} from '../dto';\nimport { DeviceCreateInput } from '@/src/generated/models';\n\n/**\n * Main KeyGuard service handling device enrollment and signature verification\n */\n@Injectable()\nexport class KeyGuardService {\n  private readonly logger = new Logger(KeyGuardService.name);\n\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly signatureVerification: SignatureVerificationService,\n  ) {}\n\n  /**\n   * Enroll a new device by storing its public key\n   *\n   * @param apiKey - Project API key from header\n   * @param enrollDto - Enrollment data from SDK\n   * @returns Device ID and status\n   */\n  async enrollDevice(\n    apiKey: string,\n    enrollDto: EnrollDeviceDto,\n  ): Promise<EnrollResponseDto> {\n    this.logger.log(`Enrolling device with keyId: ${enrollDto.keyId}`);\n\n    // Validate API key and get project\n    const project = await this.validateApiKey(apiKey);\n\n    // Check if device with same keyId already exists\n    const existingDevice = await this.prisma.prisma.device.findUnique({\n      where: {\n        apiKeyId_keyId: {\n          apiKeyId: project.id,\n          keyId: enrollDto.keyId,\n        },\n      },\n    });\n\n    if (existingDevice) {\n      throw new BadRequestException(\n        `Device with keyId ${enrollDto.keyId} already enrolled`,\n      );\n    }\n\n    // Validate public key format (basic check)\n    this.validatePublicKey(enrollDto.publicKey);\n\n    // Create device record\n    const deviceData: DeviceCreateInput = {\n      keyId: enrollDto.keyId,\n      publicKeySpkiBase64: enrollDto.publicKey,\n      fingerprint: enrollDto.deviceFingerprint,\n      label: enrollDto.label,\n      status: 'ACTIVE',\n      apiKey: {\n        connect: {\n          id: project.id,\n        },\n      },\n    };\n\n    // Only add optional fields if they exist\n    if (enrollDto.userAgent) {\n      deviceData.userAgent = enrollDto.userAgent;\n    }\n    if (enrollDto.metadata) {\n      deviceData.metadata = enrollDto.metadata;\n    }\n\n    const device = await this.prisma.prisma.device.create({\n      data: deviceData,\n    });\n\n    this.logger.log(`Device enrolled successfully: ${device.id}`);\n\n    return {\n      id: device.id,\n      status: device.status,\n      createdAt: device.createdAt,\n    };\n  }\n\n  /**\n   * Verify a signed request\n   *\n   * @param headers - KeyGuard headers from request\n   * @param method - HTTP method\n   * @param url - Request URL (path and query)\n   * @param rawBody - Raw request body buffer\n   * @returns Verification result\n   */\n  async verifyRequest(\n    headers: KeyGuardHeaders,\n    method: string,\n    url: string,\n    rawBody: Buffer | null,\n  ): Promise<VerifyResponseDto> {\n    try {\n      this.logger.log(\n        `Verifying request for keyId: ${headers.keyId}, apiKey: ${headers.apiKey}`,\n      );\n\n      // 1. Validate algorithm\n      if (!this.signatureVerification.validateAlgorithm(headers.algorithm)) {\n        return {\n          valid: false,\n          error: `Unsupported algorithm: ${headers.algorithm}`,\n        };\n      }\n\n      // 2. Validate timestamp (120 second window)\n      if (!this.signatureVerification.validateTimestamp(headers.timestamp)) {\n        return {\n          valid: false,\n          error: 'Request timestamp outside valid window',\n        };\n      }\n\n      // 3. Validate API key and get project\n      const project = await this.validateApiKey(headers.apiKey);\n\n      // 4. Get device and public key\n      const device = await this.prisma.prisma.device.findUnique({\n        where: {\n          apiKeyId_keyId: {\n            apiKeyId: project.id,\n            keyId: headers.keyId,\n          },\n        },\n      });\n\n      if (!device) {\n        return {\n          valid: false,\n          error: `Device with keyId ${headers.keyId} not found`,\n        };\n      }\n\n      if (device.status !== 'ACTIVE') {\n        return {\n          valid: false,\n          error: `Device status is ${device.status}`,\n        };\n      }\n\n      // 5. Check nonce uniqueness (replay protection)\n      const nonceExists = await this.checkNonceExists(\n        project.id,\n        headers.keyId,\n        headers.nonce,\n      );\n\n      if (nonceExists) {\n        return {\n          valid: false,\n          error: 'Nonce has already been used (replay attack detected)',\n        };\n      }\n\n      // 6. Compute body hash and compare\n      const computedBodyHash =\n        this.signatureVerification.computeBodyHash(rawBody);\n\n      if (computedBodyHash !== headers.bodySha256) {\n        this.logger.warn(\n          `Body hash mismatch. Expected: ${headers.bodySha256}, Got: ${computedBodyHash}`,\n        );\n        return {\n          valid: false,\n          error: 'Body hash mismatch',\n        };\n      }\n\n      // 7. Build canonical payload\n      const pathAndQuery =\n        this.signatureVerification.extractPathAndQuery(url);\n      const canonicalPayload =\n        this.signatureVerification.buildCanonicalPayload(\n          headers.timestamp,\n          method,\n          pathAndQuery,\n          headers.bodySha256,\n          headers.nonce,\n          headers.apiKey,\n          headers.keyId,\n        );\n\n      // 8. Verify signature\n      const isValid = await this.signatureVerification.verifySignature(\n        device.publicKeySpkiBase64,\n        canonicalPayload,\n        headers.signature,\n      );\n\n      if (!isValid) {\n        return {\n          valid: false,\n          error: 'Invalid signature',\n        };\n      }\n\n      // 9. Store nonce to prevent replay (TTL: 120 seconds)\n      await this.storeNonce(project.id, headers.keyId, headers.nonce);\n\n      // 10. Update last seen timestamp\n      await this.prisma.prisma.device.update({\n        where: { id: device.id },\n        data: { lastSeenAt: new Date() },\n      });\n\n      this.logger.log(`Request verified successfully for device: ${device.id}`);\n\n      return {\n        valid: true,\n        deviceId: device.id,\n        keyId: device.keyId,\n      };\n    } catch (error) {\n      this.logger.error('Verification error:', error);\n      return {\n        valid: false,\n        error: error instanceof Error ? error.message : 'Verification failed',\n      };\n    }\n  }\n\n  /**\n   * Get device by ID\n   */\n  async getDevice(deviceId: string) {\n    const device = await this.prisma.prisma.device.findUnique({\n      where: { id: deviceId },\n      include: { apiKey: true },\n    });\n\n    if (!device) {\n      throw new NotFoundException(`Device ${deviceId} not found`);\n    }\n\n    return device;\n  }\n\n  /**\n   * List all devices for an API key\n   */\n  async listDevices(apiKey: string) {\n    const project = await this.validateApiKey(apiKey);\n\n    const devices = await this.prisma.prisma.device.findMany({\n      where: { apiKeyId: project.id },\n      orderBy: { createdAt: 'desc' },\n    });\n\n    return devices;\n  }\n\n  /**\n   * Revoke a device\n   */\n  async revokeDevice(apiKey: string, deviceId: string) {\n    const project = await this.validateApiKey(apiKey);\n\n    const device = await this.prisma.prisma.device.findFirst({\n      where: {\n        id: deviceId,\n        apiKeyId: project.id,\n      },\n    });\n\n    if (!device) {\n      throw new NotFoundException(`Device ${deviceId} not found`);\n    }\n\n    const updated = await this.prisma.prisma.device.update({\n      where: { id: deviceId },\n      data: { status: 'REVOKED' },\n    });\n\n    this.logger.log(`Device revoked: ${deviceId}`);\n    return updated;\n  }\n\n  /**\n   * Validate API key exists and is active\n   */\n  private async validateApiKey(apiKey: string) {\n    if (!apiKey) {\n      throw new BadRequestException('API key is required');\n    }\n\n    // Extract key prefix (e.g., kg_prod_123 -> kg_prod)\n    const keyPrefix = apiKey.split('_').slice(0, 2).join('_');\n\n    const project = await this.prisma.prisma.apiKey.findFirst({\n      where: {\n        keyPrefix,\n      },\n    });\n\n    if (!project) {\n      throw new UnauthorizedException('Invalid API key');\n    }\n\n    if (project.status !== 'ACTIVE') {\n      throw new UnauthorizedException('API key is not active');\n    }\n\n    return project;\n  }\n\n  /**\n   * Validate public key format (basic validation)\n   */\n  private validatePublicKey(publicKey: string) {\n    // Check if it's valid base64\n    const base64Regex = /^[A-Za-z0-9+/]+=*$/;\n    if (!base64Regex.test(publicKey)) {\n      throw new BadRequestException('Invalid public key format');\n    }\n\n    // Check reasonable length (SPKI P-256 keys are ~91 base64 chars)\n    if (publicKey.length < 50 || publicKey.length > 200) {\n      throw new BadRequestException('Public key length out of valid range');\n    }\n  }\n\n  /**\n   * Check if nonce has been used\n   */\n  private async checkNonceExists(\n    apiKeyId: string,\n    keyId: string,\n    nonce: string,\n  ): Promise<boolean> {\n    const existing = await this.prisma.prisma.nonce.findUnique({\n      where: {\n        apiKeyId_keyId_nonce: {\n          apiKeyId,\n          keyId,\n          nonce,\n        },\n      },\n    });\n\n    return !!existing;\n  }\n\n  /**\n   * Store nonce with TTL (120 seconds)\n   */\n  private async storeNonce(\n    apiKeyId: string,\n    keyId: string,\n    nonce: string,\n  ): Promise<void> {\n    const expiresAt = new Date(Date.now() + 120 * 1000); // 120 seconds\n\n    await this.prisma.prisma.nonce.create({\n      data: {\n        apiKeyId,\n        keyId,\n        nonce,\n        expiresAt,\n      },\n    });\n  }\n\n  /**\n   * Clean up expired nonces (should be run periodically via cron)\n   */\n  async cleanupExpiredNonces(): Promise<number> {\n    const result = await this.prisma.prisma.nonce.deleteMany({\n      where: {\n        expiresAt: {\n          lt: new Date(),\n        },\n      },\n    });\n\n    this.logger.log(`Cleaned up ${result.count} expired nonces`);\n    return result.count;\n  }\n}\n"],"names":["KeyGuardService","enrollDevice","apiKey","enrollDto","logger","log","keyId","project","validateApiKey","existingDevice","prisma","device","findUnique","where","apiKeyId_keyId","apiKeyId","id","BadRequestException","validatePublicKey","publicKey","deviceData","publicKeySpkiBase64","fingerprint","deviceFingerprint","label","status","connect","userAgent","metadata","create","data","createdAt","verifyRequest","headers","method","url","rawBody","signatureVerification","validateAlgorithm","algorithm","valid","error","validateTimestamp","timestamp","nonceExists","checkNonceExists","nonce","computedBodyHash","computeBodyHash","bodySha256","warn","pathAndQuery","extractPathAndQuery","canonicalPayload","buildCanonicalPayload","isValid","verifySignature","signature","storeNonce","update","lastSeenAt","Date","deviceId","Error","message","getDevice","include","NotFoundException","listDevices","devices","findMany","orderBy","revokeDevice","findFirst","updated","keyPrefix","split","slice","join","UnauthorizedException","base64Regex","test","length","existing","apiKeyId_keyId_nonce","expiresAt","now","cleanupExpiredNonces","result","deleteMany","lt","count","Logger","name"],"mappings":"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"}