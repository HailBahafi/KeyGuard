{"version":3,"sources":["../../../../src/modules/keyguard/services/keyguard.service.spec.ts"],"sourcesContent":["import { Test, TestingModule } from '@nestjs/testing';\nimport { KeyGuardService } from './keyguard.service';\nimport { SignatureVerificationService } from './signature-verification.service';\nimport { PrismaService } from '@/src/core/database/prisma.service';\nimport {\n  BadRequestException,\n  UnauthorizedException,\n  NotFoundException,\n} from '@nestjs/common';\n\ndescribe('KeyGuardService', () => {\n  let service: KeyGuardService;\n  let prismaService: PrismaService;\n  let signatureService: SignatureVerificationService;\n\n  const mockPrismaService = {\n    prisma: {\n      apiKey: {\n        findFirst: jest.fn(),\n      },\n      device: {\n        findUnique: jest.fn(),\n        findFirst: jest.fn(),\n        findMany: jest.fn(),\n        create: jest.fn(),\n        update: jest.fn(),\n      },\n      nonce: {\n        findUnique: jest.fn(),\n        create: jest.fn(),\n        deleteMany: jest.fn(),\n      },\n    },\n  };\n\n  const mockSignatureService = {\n    validateAlgorithm: jest.fn(),\n    validateTimestamp: jest.fn(),\n    computeBodyHash: jest.fn(),\n    extractPathAndQuery: jest.fn(),\n    buildCanonicalPayload: jest.fn(),\n    verifySignature: jest.fn(),\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        KeyGuardService,\n        {\n          provide: PrismaService,\n          useValue: mockPrismaService,\n        },\n        {\n          provide: SignatureVerificationService,\n          useValue: mockSignatureService,\n        },\n      ],\n    }).compile();\n\n    service = module.get<KeyGuardService>(KeyGuardService);\n    prismaService = module.get<PrismaService>(PrismaService);\n    signatureService = module.get<SignatureVerificationService>(\n      SignatureVerificationService,\n    );\n\n    // Reset mocks\n    jest.clearAllMocks();\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n\n  describe('enrollDevice', () => {\n    const apiKey = 'kg_prod_123';\n    const enrollDto = {\n      publicKey: 'MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE...',\n      keyId: 'key_abc123',\n      deviceFingerprint: 'fingerprint123',\n      label: \"Ahmed's MacBook\",\n      userAgent: 'Mozilla/5.0...',\n      metadata: { browser: 'Chrome' },\n    };\n\n    const mockProject = {\n      id: 'project-uuid',\n      keyPrefix: 'kg_prod',\n      name: 'Test Project',\n      status: 'ACTIVE',\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    it('should successfully enroll a device', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue(null);\n      mockPrismaService.prisma.device.create.mockResolvedValue({\n        id: 'device-uuid',\n        status: 'ACTIVE',\n        createdAt: new Date(),\n        ...enrollDto,\n        apiKeyId: mockProject.id,\n      });\n\n      const result = await service.enrollDevice(apiKey, enrollDto);\n\n      expect(result).toEqual({\n        id: 'device-uuid',\n        status: 'ACTIVE',\n        createdAt: expect.any(Date),\n      });\n\n      expect(mockPrismaService.prisma.apiKey.findFirst).toHaveBeenCalledWith({\n        where: { keyPrefix: 'kg_prod' },\n      });\n      expect(mockPrismaService.prisma.device.create).toHaveBeenCalled();\n    });\n\n    it('should throw error if API key is missing', async () => {\n      await expect(service.enrollDevice('', enrollDto)).rejects.toThrow(\n        BadRequestException,\n      );\n    });\n\n    it('should throw error if API key is invalid', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(null);\n\n      await expect(service.enrollDevice(apiKey, enrollDto)).rejects.toThrow(\n        UnauthorizedException,\n      );\n    });\n\n    it('should throw error if API key is not active', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue({\n        ...mockProject,\n        status: 'INACTIVE',\n      });\n\n      await expect(service.enrollDevice(apiKey, enrollDto)).rejects.toThrow(\n        UnauthorizedException,\n      );\n    });\n\n    it('should throw error if device already enrolled', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue({\n        id: 'existing-device',\n        keyId: enrollDto.keyId,\n      });\n\n      await expect(service.enrollDevice(apiKey, enrollDto)).rejects.toThrow(\n        BadRequestException,\n      );\n    });\n\n    it('should throw error for invalid public key format', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue(null);\n\n      const invalidDto = { ...enrollDto, publicKey: 'invalid-key!!!' };\n\n      await expect(service.enrollDevice(apiKey, invalidDto)).rejects.toThrow(\n        BadRequestException,\n      );\n    });\n\n    it('should throw error for public key that is too short', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue(null);\n\n      const invalidDto = { ...enrollDto, publicKey: 'ABC123' };\n\n      await expect(service.enrollDevice(apiKey, invalidDto)).rejects.toThrow(\n        BadRequestException,\n      );\n    });\n  });\n\n  describe('verifyRequest', () => {\n    const headers = {\n      apiKey: 'kg_prod_123',\n      keyId: 'key_abc123',\n      timestamp: '2025-12-02T10:30:00.000Z',\n      nonce: 'nonce123',\n      bodySha256: 'hash123',\n      algorithm: 'ECDSA_P256_SHA256_P1363',\n      signature: 'signature_base64',\n    };\n\n    const method = 'POST';\n    const url = '/api/v1/verify-test';\n    const rawBody = Buffer.from('{}');\n\n    const mockProject = {\n      id: 'project-uuid',\n      keyPrefix: 'kg_prod',\n      status: 'ACTIVE',\n    };\n\n    const mockDevice = {\n      id: 'device-uuid',\n      keyId: headers.keyId,\n      publicKeySpkiBase64: 'public_key_base64',\n      status: 'ACTIVE',\n      apiKeyId: mockProject.id,\n    };\n\n    beforeEach(() => {\n      mockSignatureService.validateAlgorithm.mockReturnValue(true);\n      mockSignatureService.validateTimestamp.mockReturnValue(true);\n      mockSignatureService.computeBodyHash.mockReturnValue(headers.bodySha256);\n      mockSignatureService.extractPathAndQuery.mockReturnValue(url);\n      mockSignatureService.buildCanonicalPayload.mockReturnValue(\n        'canonical_payload',\n      );\n      mockSignatureService.verifySignature.mockResolvedValue(true);\n    });\n\n    it('should successfully verify request', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue(mockDevice);\n      mockPrismaService.prisma.nonce.findUnique.mockResolvedValue(null);\n      mockPrismaService.prisma.nonce.create.mockResolvedValue({});\n      mockPrismaService.prisma.device.update.mockResolvedValue(mockDevice);\n\n      const result = await service.verifyRequest(\n        headers,\n        method,\n        url,\n        rawBody,\n      );\n\n      expect(result).toEqual({\n        valid: true,\n        deviceId: mockDevice.id,\n        keyId: mockDevice.keyId,\n      });\n    });\n\n    it('should reject invalid algorithm', async () => {\n      mockSignatureService.validateAlgorithm.mockReturnValue(false);\n\n      const result = await service.verifyRequest(\n        headers,\n        method,\n        url,\n        rawBody,\n      );\n\n      expect(result).toEqual({\n        valid: false,\n        error: expect.stringContaining('algorithm'),\n      });\n    });\n\n    it('should reject invalid timestamp', async () => {\n      mockSignatureService.validateTimestamp.mockReturnValue(false);\n\n      const result = await service.verifyRequest(\n        headers,\n        method,\n        url,\n        rawBody,\n      );\n\n      expect(result).toEqual({\n        valid: false,\n        error: expect.stringContaining('timestamp'),\n      });\n    });\n\n    it('should reject if device not found', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue(null);\n\n      const result = await service.verifyRequest(\n        headers,\n        method,\n        url,\n        rawBody,\n      );\n\n      expect(result).toEqual({\n        valid: false,\n        error: expect.stringContaining('not found'),\n      });\n    });\n\n    it('should reject if device is not active', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue({\n        ...mockDevice,\n        status: 'REVOKED',\n      });\n\n      const result = await service.verifyRequest(\n        headers,\n        method,\n        url,\n        rawBody,\n      );\n\n      expect(result).toEqual({\n        valid: false,\n        error: expect.stringContaining('REVOKED'),\n      });\n    });\n\n    it('should reject replay attack (nonce reuse)', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue(mockDevice);\n      mockPrismaService.prisma.nonce.findUnique.mockResolvedValue({\n        id: 'nonce-uuid',\n        nonce: headers.nonce,\n      });\n\n      const result = await service.verifyRequest(\n        headers,\n        method,\n        url,\n        rawBody,\n      );\n\n      expect(result).toEqual({\n        valid: false,\n        error: expect.stringContaining('replay'),\n      });\n    });\n\n    it('should reject body hash mismatch', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue(mockDevice);\n      mockPrismaService.prisma.nonce.findUnique.mockResolvedValue(null);\n      mockSignatureService.computeBodyHash.mockReturnValue('different_hash');\n\n      const result = await service.verifyRequest(\n        headers,\n        method,\n        url,\n        rawBody,\n      );\n\n      expect(result).toEqual({\n        valid: false,\n        error: expect.stringContaining('Body hash'),\n      });\n    });\n\n    it('should reject invalid signature', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue(mockDevice);\n      mockPrismaService.prisma.nonce.findUnique.mockResolvedValue(null);\n      mockSignatureService.verifySignature.mockResolvedValue(false);\n\n      const result = await service.verifyRequest(\n        headers,\n        method,\n        url,\n        rawBody,\n      );\n\n      expect(result).toEqual({\n        valid: false,\n        error: expect.stringContaining('Invalid signature'),\n      });\n    });\n\n    it('should update lastSeenAt on successful verification', async () => {\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue(mockDevice);\n      mockPrismaService.prisma.nonce.findUnique.mockResolvedValue(null);\n      mockPrismaService.prisma.nonce.create.mockResolvedValue({});\n      mockPrismaService.prisma.device.update.mockResolvedValue(mockDevice);\n\n      await service.verifyRequest(headers, method, url, rawBody);\n\n      expect(mockPrismaService.prisma.device.update).toHaveBeenCalledWith({\n        where: { id: mockDevice.id },\n        data: { lastSeenAt: expect.any(Date) },\n      });\n    });\n  });\n\n  describe('getDevice', () => {\n    it('should return device by ID', async () => {\n      const mockDevice = {\n        id: 'device-uuid',\n        keyId: 'key_abc',\n        status: 'ACTIVE',\n        apiKey: { id: 'project-uuid', name: 'Test Project' },\n      };\n\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue(mockDevice);\n\n      const result = await service.getDevice('device-uuid');\n\n      expect(result).toEqual(mockDevice);\n    });\n\n    it('should throw error if device not found', async () => {\n      mockPrismaService.prisma.device.findUnique.mockResolvedValue(null);\n\n      await expect(service.getDevice('device-uuid')).rejects.toThrow(\n        NotFoundException,\n      );\n    });\n  });\n\n  describe('listDevices', () => {\n    it('should list all devices for an API key', async () => {\n      const mockProject = {\n        id: 'project-uuid',\n        keyPrefix: 'kg_prod',\n        status: 'ACTIVE',\n      };\n\n      const mockDevices = [\n        { id: 'device-1', keyId: 'key_1', status: 'ACTIVE' },\n        { id: 'device-2', keyId: 'key_2', status: 'REVOKED' },\n      ];\n\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findMany.mockResolvedValue(mockDevices);\n\n      const result = await service.listDevices('kg_prod_123');\n\n      expect(result).toEqual(mockDevices);\n      expect(mockPrismaService.prisma.device.findMany).toHaveBeenCalledWith({\n        where: { apiKeyId: mockProject.id },\n        orderBy: { createdAt: 'desc' },\n      });\n    });\n  });\n\n  describe('revokeDevice', () => {\n    it('should revoke a device', async () => {\n      const mockProject = {\n        id: 'project-uuid',\n        keyPrefix: 'kg_prod',\n        status: 'ACTIVE',\n      };\n\n      const mockDevice = {\n        id: 'device-uuid',\n        keyId: 'key_abc',\n        status: 'ACTIVE',\n        apiKeyId: mockProject.id,\n      };\n\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findFirst.mockResolvedValue(mockDevice);\n      mockPrismaService.prisma.device.update.mockResolvedValue({\n        ...mockDevice,\n        status: 'REVOKED',\n      });\n\n      const result = await service.revokeDevice('kg_prod_123', 'device-uuid');\n\n      expect(result.status).toBe('REVOKED');\n      expect(mockPrismaService.prisma.device.update).toHaveBeenCalledWith({\n        where: { id: 'device-uuid' },\n        data: { status: 'REVOKED' },\n      });\n    });\n\n    it('should throw error if device not found', async () => {\n      const mockProject = {\n        id: 'project-uuid',\n        keyPrefix: 'kg_prod',\n        status: 'ACTIVE',\n      };\n\n      mockPrismaService.prisma.apiKey.findFirst.mockResolvedValue(mockProject);\n      mockPrismaService.prisma.device.findFirst.mockResolvedValue(null);\n\n      await expect(\n        service.revokeDevice('kg_prod_123', 'device-uuid'),\n      ).rejects.toThrow(NotFoundException);\n    });\n  });\n\n  describe('cleanupExpiredNonces', () => {\n    it('should delete expired nonces', async () => {\n      mockPrismaService.prisma.nonce.deleteMany.mockResolvedValue({\n        count: 5,\n      });\n\n      const count = await service.cleanupExpiredNonces();\n\n      expect(count).toBe(5);\n      expect(mockPrismaService.prisma.nonce.deleteMany).toHaveBeenCalledWith({\n        where: {\n          expiresAt: {\n            lt: expect.any(Date),\n          },\n        },\n      });\n    });\n  });\n});\n"],"names":["describe","service","prismaService","signatureService","mockPrismaService","prisma","apiKey","findFirst","jest","fn","device","findUnique","findMany","create","update","nonce","deleteMany","mockSignatureService","validateAlgorithm","validateTimestamp","computeBodyHash","extractPathAndQuery","buildCanonicalPayload","verifySignature","beforeEach","module","Test","createTestingModule","providers","KeyGuardService","provide","PrismaService","useValue","SignatureVerificationService","compile","get","clearAllMocks","it","expect","toBeDefined","enrollDto","publicKey","keyId","deviceFingerprint","label","userAgent","metadata","browser","mockProject","id","keyPrefix","name","status","createdAt","Date","updatedAt","mockResolvedValue","apiKeyId","result","enrollDevice","toEqual","any","toHaveBeenCalledWith","where","toHaveBeenCalled","rejects","toThrow","BadRequestException","UnauthorizedException","invalidDto","headers","timestamp","bodySha256","algorithm","signature","method","url","rawBody","Buffer","from","mockDevice","publicKeySpkiBase64","mockReturnValue","verifyRequest","valid","deviceId","error","stringContaining","data","lastSeenAt","getDevice","NotFoundException","mockDevices","listDevices","orderBy","revokeDevice","toBe","count","cleanupExpiredNonces","expiresAt","lt"],"mappings":"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"}