{"version":3,"sources":["../../../../src/modules/keyguard/services/signature-verification.service.spec.ts"],"sourcesContent":["import { Test, TestingModule } from '@nestjs/testing';\nimport { SignatureVerificationService } from './signature-verification.service';\nimport { webcrypto } from 'node:crypto';\n\ndescribe('SignatureVerificationService', () => {\n  let service: SignatureVerificationService;\n\n  // Test keys generated for testing\n  const testPublicKeyBase64 =\n    'MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEhKMl+ER0xKjBBHdGKn8V0eKF2VwmzYfqLQQp7gxYQVW5tLxI+YwZx8gLYQzCf+9hZF8dZzWYGQhLxLVJGxhZEw==';\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [SignatureVerificationService],\n    }).compile();\n\n    service = module.get<SignatureVerificationService>(\n      SignatureVerificationService,\n    );\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n\n  describe('buildCanonicalPayload', () => {\n    it('should build correct canonical payload', () => {\n      const timestamp = '2025-12-02T10:30:00.000Z';\n      const method = 'POST';\n      const pathAndQuery = '/api/v1/enroll';\n      const bodySha256 = 'abc123';\n      const nonce = 'nonce123';\n      const apiKey = 'kg_prod_123';\n      const keyId = 'key_abc';\n\n      const payload = service.buildCanonicalPayload(\n        timestamp,\n        method,\n        pathAndQuery,\n        bodySha256,\n        nonce,\n        apiKey,\n        keyId,\n      );\n\n      expect(payload).toBe(\n        'kg-v1|2025-12-02T10:30:00.000Z|POST|/api/v1/enroll|abc123|nonce123|kg_prod_123|key_abc',\n      );\n    });\n\n    it('should uppercase HTTP method', () => {\n      const payload = service.buildCanonicalPayload(\n        '2025-12-02T10:30:00.000Z',\n        'post',\n        '/api/v1/test',\n        'hash',\n        'nonce',\n        'api_key',\n        'key_id',\n      );\n\n      expect(payload).toContain('|POST|');\n    });\n  });\n\n  describe('computeBodyHash', () => {\n    it('should compute SHA-256 hash of body', () => {\n      const body = Buffer.from('{\"test\":\"data\"}', 'utf8');\n      const hash = service.computeBodyHash(body);\n\n      // Expected hash for {\"test\":\"data\"}\n      expect(hash).toBe(\n        '0e3ee8634d03a0ba7db6fe5b7f0ad2a4fef45a5c3bfa8d7dc57b6f3c4dbe5e4f',\n      );\n      expect(hash.length).toBe(64); // SHA-256 hex length\n    });\n\n    it('should handle empty body', () => {\n      const hash = service.computeBodyHash(null);\n\n      // Expected hash for empty string\n      expect(hash).toBe(\n        'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855',\n      );\n    });\n\n    it('should handle empty buffer', () => {\n      const hash = service.computeBodyHash(Buffer.from(''));\n\n      // Expected hash for empty string\n      expect(hash).toBe(\n        'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855',\n      );\n    });\n  });\n\n  describe('validateTimestamp', () => {\n    it('should accept timestamp within window', () => {\n      const now = new Date();\n      const timestamp = now.toISOString();\n\n      const isValid = service.validateTimestamp(timestamp, 120);\n\n      expect(isValid).toBe(true);\n    });\n\n    it('should reject timestamp outside window', () => {\n      const past = new Date(Date.now() - 200 * 1000); // 200 seconds ago\n      const timestamp = past.toISOString();\n\n      const isValid = service.validateTimestamp(timestamp, 120);\n\n      expect(isValid).toBe(false);\n    });\n\n    it('should accept future timestamp within window', () => {\n      const future = new Date(Date.now() + 60 * 1000); // 60 seconds in future\n      const timestamp = future.toISOString();\n\n      const isValid = service.validateTimestamp(timestamp, 120);\n\n      expect(isValid).toBe(true);\n    });\n\n    it('should reject invalid timestamp format', () => {\n      const isValid = service.validateTimestamp('invalid-date');\n\n      expect(isValid).toBe(false);\n    });\n  });\n\n  describe('extractPathAndQuery', () => {\n    it('should extract path and query from full URL', () => {\n      const url = 'https://example.com/api/v1/test?foo=bar';\n      const result = service.extractPathAndQuery(url);\n\n      expect(result).toBe('/api/v1/test?foo=bar');\n    });\n\n    it('should handle path without query', () => {\n      const url = 'https://example.com/api/v1/test';\n      const result = service.extractPathAndQuery(url);\n\n      expect(result).toBe('/api/v1/test');\n    });\n\n    it('should return path if already just a path', () => {\n      const url = '/api/v1/test?foo=bar';\n      const result = service.extractPathAndQuery(url);\n\n      expect(result).toBe('/api/v1/test?foo=bar');\n    });\n\n    it('should handle HTTP URLs', () => {\n      const url = 'http://localhost:3000/api/v1/test';\n      const result = service.extractPathAndQuery(url);\n\n      expect(result).toBe('/api/v1/test');\n    });\n  });\n\n  describe('validateAlgorithm', () => {\n    it('should accept supported algorithm', () => {\n      const isValid = service.validateAlgorithm('ECDSA_P256_SHA256_P1363');\n\n      expect(isValid).toBe(true);\n    });\n\n    it('should reject unsupported algorithm', () => {\n      const isValid = service.validateAlgorithm('ECDSA_P384_SHA384');\n\n      expect(isValid).toBe(false);\n    });\n\n    it('should reject empty algorithm', () => {\n      const isValid = service.validateAlgorithm('');\n\n      expect(isValid).toBe(false);\n    });\n  });\n\n  describe('verifySignature', () => {\n    let publicKey: webcrypto.CryptoKey;\n    let privateKey: webcrypto.CryptoKey;\n    let publicKeyBase64: string;\n\n    beforeEach(async () => {\n      // Generate a test key pair\n      const keyPair = await webcrypto.subtle.generateKey(\n        {\n          name: 'ECDSA',\n          namedCurve: 'P-256',\n        },\n        true,\n        ['sign', 'verify'],\n      );\n\n      publicKey = keyPair.publicKey;\n      privateKey = keyPair.privateKey;\n\n      // Export public key to SPKI format\n      const publicKeyBuffer = await webcrypto.subtle.exportKey(\n        'spki',\n        publicKey,\n      );\n      publicKeyBase64 = Buffer.from(publicKeyBuffer).toString('base64');\n    });\n\n    it('should verify valid signature', async () => {\n      const payload = 'kg-v1|2025-12-02T10:30:00.000Z|POST|/api/v1/test|hash|nonce|api|key';\n\n      // Sign the payload\n      const signature = await webcrypto.subtle.sign(\n        { name: 'ECDSA', hash: { name: 'SHA-256' } },\n        privateKey,\n        Buffer.from(payload, 'utf8'),\n      );\n      const signatureBase64 = Buffer.from(signature).toString('base64');\n\n      // Verify\n      const isValid = await service.verifySignature(\n        publicKeyBase64,\n        payload,\n        signatureBase64,\n      );\n\n      expect(isValid).toBe(true);\n    });\n\n    it('should reject invalid signature', async () => {\n      const payload = 'kg-v1|2025-12-02T10:30:00.000Z|POST|/api/v1/test|hash|nonce|api|key';\n      const invalidSignature = Buffer.from('invalid-signature').toString(\n        'base64',\n      );\n\n      const isValid = await service.verifySignature(\n        publicKeyBase64,\n        payload,\n        invalidSignature,\n      );\n\n      expect(isValid).toBe(false);\n    });\n\n    it('should reject signature with modified payload', async () => {\n      const originalPayload = 'kg-v1|2025-12-02T10:30:00.000Z|POST|/api/v1/test|hash|nonce|api|key';\n\n      // Sign original payload\n      const signature = await webcrypto.subtle.sign(\n        { name: 'ECDSA', hash: { name: 'SHA-256' } },\n        privateKey,\n        Buffer.from(originalPayload, 'utf8'),\n      );\n      const signatureBase64 = Buffer.from(signature).toString('base64');\n\n      // Verify with modified payload\n      const modifiedPayload = 'kg-v1|2025-12-02T10:30:00.000Z|POST|/api/v1/test|modified|nonce|api|key';\n      const isValid = await service.verifySignature(\n        publicKeyBase64,\n        modifiedPayload,\n        signatureBase64,\n      );\n\n      expect(isValid).toBe(false);\n    });\n\n    it('should reject signature with invalid public key', async () => {\n      const payload = 'kg-v1|2025-12-02T10:30:00.000Z|POST|/api/v1/test|hash|nonce|api|key';\n\n      // Sign the payload\n      const signature = await webcrypto.subtle.sign(\n        { name: 'ECDSA', hash: { name: 'SHA-256' } },\n        privateKey,\n        Buffer.from(payload, 'utf8'),\n      );\n      const signatureBase64 = Buffer.from(signature).toString('base64');\n\n      // Try to verify with different public key\n      const invalidPublicKey = testPublicKeyBase64;\n\n      const isValid = await service.verifySignature(\n        invalidPublicKey,\n        payload,\n        signatureBase64,\n      );\n\n      expect(isValid).toBe(false);\n    });\n  });\n});\n"],"names":["describe","service","testPublicKeyBase64","beforeEach","module","Test","createTestingModule","providers","SignatureVerificationService","compile","get","it","expect","toBeDefined","timestamp","method","pathAndQuery","bodySha256","nonce","apiKey","keyId","payload","buildCanonicalPayload","toBe","toContain","body","Buffer","from","hash","computeBodyHash","length","now","Date","toISOString","isValid","validateTimestamp","past","future","url","result","extractPathAndQuery","validateAlgorithm","publicKey","privateKey","publicKeyBase64","keyPair","webcrypto","subtle","generateKey","name","namedCurve","publicKeyBuffer","exportKey","toString","signature","sign","signatureBase64","verifySignature","invalidSignature","originalPayload","modifiedPayload","invalidPublicKey"],"mappings":"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"}