{"version":3,"sources":["../../../src/generated/internal/prismaNamespace.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.\n * While this enables partial backward compatibility, it is not part of the stable public API.\n *\n * If you are looking for your Models, Enums, and Input Types, please import them from the respective\n * model files in the `model` directory!\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"../models\"\nimport { type PrismaClient } from \"./class\"\n\nexport type * from '../models'\n\nexport type DMMF = typeof runtime.DMMF\n\nexport type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>\n\n/**\n * Prisma Errors\n */\n\nexport const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\nexport type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n\nexport const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\nexport type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n\nexport const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\nexport type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n\nexport const PrismaClientInitializationError = runtime.PrismaClientInitializationError\nexport type PrismaClientInitializationError = runtime.PrismaClientInitializationError\n\nexport const PrismaClientValidationError = runtime.PrismaClientValidationError\nexport type PrismaClientValidationError = runtime.PrismaClientValidationError\n\n/**\n * Re-export of sql-template-tag\n */\nexport const sql = runtime.sqltag\nexport const empty = runtime.empty\nexport const join = runtime.join\nexport const raw = runtime.raw\nexport const Sql = runtime.Sql\nexport type Sql = runtime.Sql\n\n\n\n/**\n * Decimal.js\n */\nexport const Decimal = runtime.Decimal\nexport type Decimal = runtime.Decimal\n\nexport type DecimalJsLike = runtime.DecimalJsLike\n\n/**\n* Extensions\n*/\nexport type Extension = runtime.Types.Extensions.UserArgs\nexport const getExtensionContext = runtime.Extensions.getExtensionContext\nexport type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>\nexport type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>\nexport type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>\nexport type Exact<A, W> = runtime.Types.Public.Exact<A, W>\n\nexport type PrismaVersion = {\n  client: string\n  engine: string\n}\n\n/**\n * Prisma Client JS version: 7.0.1\n * Query Engine version: f09f2815f091dbba658cdcd2264306d88bb5bda6\n */\nexport const prismaVersion: PrismaVersion = {\n  client: \"7.0.1\",\n  engine: \"f09f2815f091dbba658cdcd2264306d88bb5bda6\"\n}\n\n/**\n * Utility Types\n */\n\nexport type Bytes = runtime.Bytes\nexport type JsonObject = runtime.JsonObject\nexport type JsonArray = runtime.JsonArray\nexport type JsonValue = runtime.JsonValue\nexport type InputJsonObject = runtime.InputJsonObject\nexport type InputJsonArray = runtime.InputJsonArray\nexport type InputJsonValue = runtime.InputJsonValue\n\n\nexport const NullTypes = {\n  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),\n  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),\n  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),\n}\n/**\n * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const DbNull = runtime.DbNull\n\n/**\n * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const JsonNull = runtime.JsonNull\n\n/**\n * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const AnyNull = runtime.AnyNull\n\n\ntype SelectAndInclude = {\n  select: any\n  include: any\n}\n\ntype SelectAndOmit = {\n  select: any\n  omit: any\n}\n\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Prisma__Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\nexport type Enumerable<T> = T | Array<T>;\n\n/**\n * Subset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n */\nexport type Subset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never;\n};\n\n/**\n * SelectSubset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n * Additionally, it validates, if both select and include are present. If the case, it errors.\n */\nexport type SelectSubset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  (T extends SelectAndInclude\n    ? 'Please either choose `select` or `include`.'\n    : T extends SelectAndOmit\n      ? 'Please either choose `select` or `omit`.'\n      : {})\n\n/**\n * Subset + Intersection\n * @desc From `T` pick properties that exist in `U` and intersect `K`\n */\nexport type SubsetIntersection<T, U, K> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  K\n\ntype Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n/**\n * XOR is needed to have a real mutually exclusive union type\n * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n */\nexport type XOR<T, U> =\n  T extends object ?\n  U extends object ?\n    (Without<T, U> & U) | (Without<U, T> & T)\n  : U : T\n\n\n/**\n * Is T a Record?\n */\ntype IsObject<T extends any> = T extends Array<any>\n? False\n: T extends Date\n? False\n: T extends Uint8Array\n? False\n: T extends BigInt\n? False\n: T extends object\n? True\n: False\n\n\n/**\n * If it's T[], return T\n */\nexport type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n/**\n * From ts-toolbelt\n */\n\ntype __Either<O extends object, K extends Key> = Omit<O, K> &\n  {\n    // Merge all but K\n    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n  }[K]\n\ntype EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\ntype EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\ntype _Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean\n> = {\n  1: EitherStrict<O, K>\n  0: EitherLoose<O, K>\n}[strict]\n\nexport type Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean = 1\n> = O extends unknown ? _Either<O, K, strict> : never\n\nexport type Union = any\n\nexport type PatchUndefined<O extends object, O1 extends object> = {\n  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n} & {}\n\n/** Helper Types for \"Merge\" **/\nexport type IntersectOf<U extends Union> = (\n  U extends unknown ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never\n\nexport type Overwrite<O extends object, O1 extends object> = {\n    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n} & {};\n\ntype _Merge<U extends object> = IntersectOf<Overwrite<U, {\n    [K in keyof U]-?: At<U, K>;\n}>>;\n\ntype Key = string | number | symbol;\ntype AtStrict<O extends object, K extends Key> = O[K & keyof O];\ntype AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\nexport type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n    1: AtStrict<O, K>;\n    0: AtLoose<O, K>;\n}[strict];\n\nexport type ComputeRaw<A extends any> = A extends Function ? A : {\n  [K in keyof A]: A[K];\n} & {};\n\nexport type OptionalFlat<O> = {\n  [K in keyof O]?: O[K];\n} & {};\n\ntype _Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\n\n// cause typescript not to expand types and preserve names\ntype NoExpand<T> = T extends unknown ? T : never;\n\n// this type assumes the passed object is entirely optional\nexport type AtLeast<O extends object, K extends string> = NoExpand<\n  O extends unknown\n  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n  : never>;\n\ntype _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\nexport type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n/** End Helper Types for \"Merge\" **/\n\nexport type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\nexport type Boolean = True | False\n\nexport type True = 1\n\nexport type False = 0\n\nexport type Not<B extends Boolean> = {\n  0: 1\n  1: 0\n}[B]\n\nexport type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n  ? 0 // anything `never` is false\n  : A1 extends A2\n  ? 1\n  : 0\n\nexport type Has<U extends Union, U1 extends Union> = Not<\n  Extends<Exclude<U1, U>, U1>\n>\n\nexport type Or<B1 extends Boolean, B2 extends Boolean> = {\n  0: {\n    0: 0\n    1: 1\n  }\n  1: {\n    0: 1\n    1: 1\n  }\n}[B1][B2]\n\nexport type Keys<U extends Union> = U extends unknown ? keyof U : never\n\nexport type GetScalarType<T, O> = O extends object ? {\n  [P in keyof T]: P extends keyof O\n    ? O[P]\n    : never\n} : never\n\ntype FieldPaths<\n  T,\n  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n> = IsObject<T> extends True ? U : T\n\nexport type GetHavingFields<T> = {\n  [K in keyof T]: Or<\n    Or<Extends<'OR', K>, Extends<'AND', K>>,\n    Extends<'NOT', K>\n  > extends True\n    ? // infer is only needed to not hit TS limit\n      // based on the brilliant idea of Pierre-Antoine Mills\n      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n      T[K] extends infer TK\n      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n      : never\n    : {} extends FieldPaths<T[K]>\n    ? never\n    : K\n}[keyof T]\n\n/**\n * Convert tuple to union\n */\ntype _TupleToUnion<T> = T extends (infer E)[] ? E : never\ntype TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\nexport type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n/**\n * Like `Pick`, but additionally can also accept an array of keys\n */\nexport type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n/**\n * Exclude all keys with underscores\n */\nexport type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\nexport type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\ntype FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\nexport const ModelName = {\n  ApiKey: 'ApiKey',\n  Device: 'Device',\n  Nonce: 'Nonce',\n  User: 'User'\n} as const\n\nexport type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n\nexport interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {\n  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>\n}\n\nexport type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n  globalOmitOptions: {\n    omit: GlobalOmitOptions\n  }\n  meta: {\n    modelProps: \"apiKey\" | \"device\" | \"nonce\" | \"user\"\n    txIsolationLevel: TransactionIsolationLevel\n  }\n  model: {\n    ApiKey: {\n      payload: Prisma.$ApiKeyPayload<ExtArgs>\n      fields: Prisma.ApiKeyFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>\n        }\n        findFirst: {\n          args: Prisma.ApiKeyFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>\n        }\n        findMany: {\n          args: Prisma.ApiKeyFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]\n        }\n        create: {\n          args: Prisma.ApiKeyCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>\n        }\n        createMany: {\n          args: Prisma.ApiKeyCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]\n        }\n        delete: {\n          args: Prisma.ApiKeyDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>\n        }\n        update: {\n          args: Prisma.ApiKeyUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>\n        }\n        deleteMany: {\n          args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]\n        }\n        upsert: {\n          args: Prisma.ApiKeyUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>\n        }\n        aggregate: {\n          args: Prisma.ApiKeyAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateApiKey>\n        }\n        groupBy: {\n          args: Prisma.ApiKeyGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ApiKeyGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ApiKeyCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ApiKeyCountAggregateOutputType> | number\n        }\n      }\n    }\n    Device: {\n      payload: Prisma.$DevicePayload<ExtArgs>\n      fields: Prisma.DeviceFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.DeviceFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevicePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevicePayload>\n        }\n        findFirst: {\n          args: Prisma.DeviceFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevicePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevicePayload>\n        }\n        findMany: {\n          args: Prisma.DeviceFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevicePayload>[]\n        }\n        create: {\n          args: Prisma.DeviceCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevicePayload>\n        }\n        createMany: {\n          args: Prisma.DeviceCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevicePayload>[]\n        }\n        delete: {\n          args: Prisma.DeviceDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevicePayload>\n        }\n        update: {\n          args: Prisma.DeviceUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevicePayload>\n        }\n        deleteMany: {\n          args: Prisma.DeviceDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.DeviceUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.DeviceUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevicePayload>[]\n        }\n        upsert: {\n          args: Prisma.DeviceUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevicePayload>\n        }\n        aggregate: {\n          args: Prisma.DeviceAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateDevice>\n        }\n        groupBy: {\n          args: Prisma.DeviceGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.DeviceGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.DeviceCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.DeviceCountAggregateOutputType> | number\n        }\n      }\n    }\n    Nonce: {\n      payload: Prisma.$NoncePayload<ExtArgs>\n      fields: Prisma.NonceFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.NonceFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoncePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.NonceFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoncePayload>\n        }\n        findFirst: {\n          args: Prisma.NonceFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoncePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.NonceFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoncePayload>\n        }\n        findMany: {\n          args: Prisma.NonceFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoncePayload>[]\n        }\n        create: {\n          args: Prisma.NonceCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoncePayload>\n        }\n        createMany: {\n          args: Prisma.NonceCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.NonceCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoncePayload>[]\n        }\n        delete: {\n          args: Prisma.NonceDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoncePayload>\n        }\n        update: {\n          args: Prisma.NonceUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoncePayload>\n        }\n        deleteMany: {\n          args: Prisma.NonceDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.NonceUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.NonceUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoncePayload>[]\n        }\n        upsert: {\n          args: Prisma.NonceUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoncePayload>\n        }\n        aggregate: {\n          args: Prisma.NonceAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateNonce>\n        }\n        groupBy: {\n          args: Prisma.NonceGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.NonceGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.NonceCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.NonceCountAggregateOutputType> | number\n        }\n      }\n    }\n    User: {\n      payload: Prisma.$UserPayload<ExtArgs>\n      fields: Prisma.UserFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.UserFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        findFirst: {\n          args: Prisma.UserFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        findMany: {\n          args: Prisma.UserFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]\n        }\n        create: {\n          args: Prisma.UserCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        createMany: {\n          args: Prisma.UserCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]\n        }\n        delete: {\n          args: Prisma.UserDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        update: {\n          args: Prisma.UserUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        deleteMany: {\n          args: Prisma.UserDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.UserUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]\n        }\n        upsert: {\n          args: Prisma.UserUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        aggregate: {\n          args: Prisma.UserAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>\n        }\n        groupBy: {\n          args: Prisma.UserGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.UserCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number\n        }\n      }\n    }\n  }\n} & {\n  other: {\n    payload: any\n    operations: {\n      $executeRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $executeRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n      $queryRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $queryRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n    }\n  }\n}\n\n/**\n * Enums\n */\n\nexport const TransactionIsolationLevel = runtime.makeStrictEnum({\n  ReadUncommitted: 'ReadUncommitted',\n  ReadCommitted: 'ReadCommitted',\n  RepeatableRead: 'RepeatableRead',\n  Serializable: 'Serializable'\n} as const)\n\nexport type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\nexport const ApiKeyScalarFieldEnum = {\n  id: 'id',\n  keyPrefix: 'keyPrefix',\n  name: 'name',\n  status: 'status',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]\n\n\nexport const DeviceScalarFieldEnum = {\n  id: 'id',\n  keyId: 'keyId',\n  publicKeySpkiBase64: 'publicKeySpkiBase64',\n  fingerprint: 'fingerprint',\n  label: 'label',\n  userAgent: 'userAgent',\n  metadata: 'metadata',\n  status: 'status',\n  apiKeyId: 'apiKeyId',\n  lastSeenAt: 'lastSeenAt',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]\n\n\nexport const NonceScalarFieldEnum = {\n  id: 'id',\n  nonce: 'nonce',\n  keyId: 'keyId',\n  apiKeyId: 'apiKeyId',\n  expiresAt: 'expiresAt',\n  createdAt: 'createdAt'\n} as const\n\nexport type NonceScalarFieldEnum = (typeof NonceScalarFieldEnum)[keyof typeof NonceScalarFieldEnum]\n\n\nexport const UserScalarFieldEnum = {\n  id: 'id',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt',\n  isActive: 'isActive',\n  lastLogin: 'lastLogin',\n  phone: 'phone',\n  email: 'email',\n  username: 'username',\n  password: 'password',\n  avatar: 'avatar',\n  role: 'role'\n} as const\n\nexport type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]\n\n\nexport const SortOrder = {\n  asc: 'asc',\n  desc: 'desc'\n} as const\n\nexport type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\nexport const NullableJsonNullValueInput = {\n  DbNull: DbNull,\n  JsonNull: JsonNull\n} as const\n\nexport type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]\n\n\nexport const QueryMode = {\n  default: 'default',\n  insensitive: 'insensitive'\n} as const\n\nexport type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\nexport const JsonNullValueFilter = {\n  DbNull: DbNull,\n  JsonNull: JsonNull,\n  AnyNull: AnyNull\n} as const\n\nexport type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]\n\n\nexport const NullsOrder = {\n  first: 'first',\n  last: 'last'\n} as const\n\nexport type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n\n/**\n * Field references\n */\n\n\n/**\n * Reference to a field of type 'String'\n */\nexport type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n/**\n * Reference to a field of type 'String[]'\n */\nexport type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n/**\n * Reference to a field of type 'ApiKeyStatus'\n */\nexport type EnumApiKeyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiKeyStatus'>\n    \n\n\n/**\n * Reference to a field of type 'ApiKeyStatus[]'\n */\nexport type ListEnumApiKeyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiKeyStatus[]'>\n    \n\n\n/**\n * Reference to a field of type 'DateTime'\n */\nexport type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n/**\n * Reference to a field of type 'DateTime[]'\n */\nexport type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n/**\n * Reference to a field of type 'Json'\n */\nexport type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>\n    \n\n\n/**\n * Reference to a field of type 'QueryMode'\n */\nexport type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>\n    \n\n\n/**\n * Reference to a field of type 'DeviceStatus'\n */\nexport type EnumDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceStatus'>\n    \n\n\n/**\n * Reference to a field of type 'DeviceStatus[]'\n */\nexport type ListEnumDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceStatus[]'>\n    \n\n\n/**\n * Reference to a field of type 'Boolean'\n */\nexport type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n\n/**\n * Reference to a field of type 'UserRole'\n */\nexport type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>\n    \n\n\n/**\n * Reference to a field of type 'UserRole[]'\n */\nexport type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>\n    \n\n\n/**\n * Reference to a field of type 'Int'\n */\nexport type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n/**\n * Reference to a field of type 'Int[]'\n */\nexport type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n\n/**\n * Batch Payload for updateMany & deleteMany & createMany\n */\nexport type BatchPayload = {\n  count: number\n}\n\nexport const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<\"define\", TypeMapCb, runtime.Types.Extensions.DefaultArgs>\nexport type DefaultPrismaClient = PrismaClient\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\nexport type PrismaClientOptions = ({\n  /**\n   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.\n   */\n  adapter: runtime.SqlDriverAdapterFactory\n  accelerateUrl?: never\n} | {\n  /**\n   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.\n   */\n  accelerateUrl: string\n  adapter?: never\n}) & {\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n  /**\n   * @example\n   * ```\n   * // Shorthand for `emit: 'stdout'`\n   * log: ['query', 'info', 'warn', 'error']\n   * \n   * // Emit as events only\n   * log: [\n   *   { emit: 'event', level: 'query' },\n   *   { emit: 'event', level: 'info' },\n   *   { emit: 'event', level: 'warn' }\n   *   { emit: 'event', level: 'error' }\n   * ]\n   * \n   * / Emit as events and log to stdout\n   * og: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   *  { emit: 'stdout', level: 'error' }\n   * \n   * ```\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n   */\n  log?: (LogLevel | LogDefinition)[]\n  /**\n   * The default values for transactionOptions\n   * maxWait ?= 2000\n   * timeout ?= 5000\n   */\n  transactionOptions?: {\n    maxWait?: number\n    timeout?: number\n    isolationLevel?: TransactionIsolationLevel\n  }\n  /**\n   * Global configuration for omitting model fields by default.\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   omit: {\n   *     user: {\n   *       password: true\n   *     }\n   *   }\n   * })\n   * ```\n   */\n  omit?: GlobalOmitConfig\n}\nexport type GlobalOmitConfig = {\n  apiKey?: Prisma.ApiKeyOmit\n  device?: Prisma.DeviceOmit\n  nonce?: Prisma.NonceOmit\n  user?: Prisma.UserOmit\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\nexport type GetLogType<T> = CheckIsLogLevel<\n  T extends LogDefinition ? T['level'] : T\n>;\n\nexport type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n  ? GetLogType<T[number]>\n  : never;\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\n\nexport type PrismaAction =\n  | 'findUnique'\n  | 'findUniqueOrThrow'\n  | 'findMany'\n  | 'findFirst'\n  | 'findFirstOrThrow'\n  | 'create'\n  | 'createMany'\n  | 'createManyAndReturn'\n  | 'update'\n  | 'updateMany'\n  | 'updateManyAndReturn'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n  | 'count'\n  | 'runCommandRaw'\n  | 'findRaw'\n  | 'groupBy'\n\n/**\n * `PrismaClient` proxy available in interactive transactions.\n */\nexport type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>\n\n"],"names":["AnyNull","ApiKeyScalarFieldEnum","DbNull","Decimal","DeviceScalarFieldEnum","JsonNull","JsonNullValueFilter","ModelName","NonceScalarFieldEnum","NullTypes","NullableJsonNullValueInput","NullsOrder","PrismaClientInitializationError","PrismaClientKnownRequestError","PrismaClientRustPanicError","PrismaClientUnknownRequestError","PrismaClientValidationError","QueryMode","SortOrder","Sql","TransactionIsolationLevel","UserScalarFieldEnum","defineExtension","empty","getExtensionContext","join","prismaVersion","raw","sql","runtime","sqltag","Extensions","client","engine","ApiKey","Device","Nonce","User","makeStrictEnum","ReadUncommitted","ReadCommitted","RepeatableRead","Serializable","id","keyPrefix","name","status","createdAt","updatedAt","keyId","publicKeySpkiBase64","fingerprint","label","userAgent","metadata","apiKeyId","lastSeenAt","nonce","expiresAt","isActive","lastLogin","phone","email","username","password","avatar","role","asc","desc","default","insensitive","first","last"],"mappings":"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"}